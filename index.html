<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <meta name="theme-color" content="#0b0f17" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>Áæ§</title>
  <style>
    html, body{
  overscroll-behavior: none;
  background-color: #0b0f17; /* Èò≤Ê≠¢È¶ñÂ∏ßÈªëÈó™ */
}
    :root{
      --cell: 28px;
      --gap: 2px;
      --bg: #0b0f17;
      --panel: #101827;
      --grid: #0f172a;
      --line: rgba(255,255,255,.06);
      --text: #e5e7eb;
      --muted:#94a3b8;
      --shadow: rgba(0,0,0,.4);
      --accent-rgb: 34,211,238; /* ÈªòËÆ§ÊôÆÈÄöÊ®°Âºè‰∏ªÈ¢òËâ≤ */
      --clear-dur: .28s;
  --energy-stagger: 46ms;
    }
    *{box-sizing:border-box}
    /* ===== Splash (Launch Screen) ===== */
.splash{
  position: fixed;
  inset: 0;
  z-index: 20000;
  display: flex;
  align-items: center;
  justify-content: center;
  background:
    /* very soft, translucent blue air from the top */
    radial-gradient(
      1400px 700px at 50% -15%,
      rgba(150,195,255,.26),
      rgba(150,195,255,.12) 28%,
      rgba(150,195,255,.04) 45%,
      rgba(150,195,255,0) 70%
    ),

    /* clearer vertical fade, lighter overall */
    linear-gradient(
      180deg,
      rgba(18,34,64,.78) 0%,
      rgba(12,22,42,.84) 45%,
      rgba(8,14,28,.92) 100%
    );
  transition: opacity .28s ease, transform .28s ease;
}
.splash.hide{
  opacity: 0;
  transform: scale(1.02);
  pointer-events: none;
}
.splash-card{
  width: min(420px, 86vw);
  text-align: center;
  padding: 18px;
  border-radius: 18px;
  background: rgba(16,24,39,.65);
  border: 1px solid rgba(255,255,255,.10);
  box-shadow: 0 18px 50px rgba(0,0,0,.45);
  backdrop-filter: blur(10px);
}
.splash-logo{
  font-weight: 950;
  letter-spacing: 2px;
  font-size: 34px;
}
.splash-sub{
  color: var(--muted);
  font-size: 13px;
}
.splash-bar{
  margin: 14px auto 0;
  width: min(280px, 72vw);
  height: 10px;
  border-radius: 999px;
  background: rgba(255,255,255,.10);
  overflow: hidden;
}
.splash-bar i{
  display:block;
  height:100%;
  width:35%;
  background: rgba(255,255,255,.25);
  animation: splashMove 1s infinite;
}
@keyframes splashMove{
  0%{transform:translateX(-10%)}
  50%{transform:translateX(180%)}
  100%{transform:translateX(-10%)}
}
    body{
      margin:0;
      min-height:100vh;
      min-height: 100svh;
      display:flex;
      align-items:center;
      justify-content:center;
      background:
        /* very soft, translucent blue air from the top */
        radial-gradient(
          1400px 700px at 50% -15%,
          rgba(150,195,255,.26),
          rgba(150,195,255,.12) 28%,
          rgba(150,195,255,.04) 45%,
          rgba(150,195,255,0) 70%
        ),

        /* clearer vertical fade, lighter overall */
        linear-gradient(
          180deg,
          rgba(18,34,64,.78) 0%,
          rgba(12,22,42,.84) 45%,
          rgba(8,14,28,.92) 100%
        );
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, "PingFang SC", "Microsoft YaHei", Arial;
      padding-bottom: calc(var(--mctl-pad, 0px) + env(safe-area-inset-bottom));
      overflow-x: hidden;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      position: relative;
    }

    /* ===== Subtle film grain / noise (Step 10) ===== */
    body::before{
      content:"";
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 0;
      opacity: .06;
      mix-blend-mode: overlay;
      background:
        repeating-linear-gradient(0deg,
          rgba(255,255,255,.08) 0px,
          rgba(255,255,255,.08) 1px,
          rgba(0,0,0,0) 2px,
          rgba(0,0,0,0) 4px),
        repeating-linear-gradient(90deg,
          rgba(255,255,255,.06) 0px,
          rgba(255,255,255,.06) 1px,
          rgba(0,0,0,0) 2px,
          rgba(0,0,0,0) 6px);
      filter: contrast(120%);
    }
    /* Ensure UI sits above noise */
    .wrap{ position: relative; z-index: 1; }
    .wrap{
      display:grid;
      grid-template-columns: auto 260px;
      gap:16px;
      padding:18px;
      background: rgba(16,24,39,.60);
      border:1px solid rgba(255,255,255,.08);
      border-radius:16px;
      box-shadow: 0 18px 40px var(--shadow);
      backdrop-filter: blur(10px);
      margin-bottom: 0;
      border-color: rgba(var(--accent-rgb), .22);
      box-shadow: 0 18px 40px var(--shadow), 0 0 0 1px rgba(var(--accent-rgb), .10);
    }
    .board{
      position:relative;
      width: calc(var(--cell) * 10 + var(--gap) * 9);
      height: calc(var(--cell) * 20 + var(--gap) * 19);
      background:
  /* subtle texture */
  repeating-linear-gradient(0deg,
    rgba(255,255,255,.03) 0px,
    rgba(255,255,255,.03) 1px,
    rgba(0,0,0,0) 2px,
    rgba(0,0,0,0) 6px),
  repeating-linear-gradient(90deg,
    rgba(255,255,255,.02) 0px,
    rgba(255,255,255,.02) 1px,
    rgba(0,0,0,0) 2px,
    rgba(0,0,0,0) 10px),
  /* accent glow */
  radial-gradient(700px 420px at 50% 0%, rgba(var(--accent-rgb), .10), rgba(0,0,0,0) 60%),
  /* base */
  linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      border:1px solid rgba(var(--accent-rgb), .22);
      border-radius:12px;
      overflow:hidden;
    }
    /* Vignette (subtle dark corners) */
.board::before{
  content:"";
  position:absolute;
  inset:0;
  pointer-events:none;
  z-index:2;
  background:
    radial-gradient(900px 520px at 50% 20%, rgba(255,255,255,.05), rgba(0,0,0,0) 55%),
    radial-gradient(900px 650px at 50% 70%, rgba(0,0,0,0), rgba(0,0,0,.55) 85%);
  mix-blend-mode: multiply;
  opacity:.9;
}
/* ===== Flash ONLY on hard drop (Space / DROP) ===== */
.board.drop-pop{
  animation: dropPop .26s ease-out;
}
@keyframes dropPop{
  0%{ box-shadow: 0 0 0 0 rgba(var(--accent-rgb), .0); }
  35%{ box-shadow: 0 0 0 3px rgba(var(--accent-rgb), .26), 0 0 30px rgba(var(--accent-rgb), .22); }
  100%{ box-shadow: 0 0 0 0 rgba(var(--accent-rgb), .0); }
}
    .grid{
      position:absolute; inset:0;
      display:grid;
      grid-template-columns: repeat(10, var(--cell));
      grid-template-rows: repeat(20, var(--cell));
      gap: var(--gap);
      padding: 0;
    }
    .cell{
      width:var(--cell); height:var(--cell);
      background: rgba(15, 23, 42, .55);
      border:1px solid rgba(255,255,255,.045);
      border-radius:5px;
      position: relative;
      overflow: hidden;
    }
    .cell.filled{
      border:none;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.18), rgba(255,255,255,.06));
    }
    /* ===== Piece color themes (subtle neon + glass) ===== */
.cell.filled.kind-I{
  background:
    /* top highlight */
    linear-gradient(180deg, rgba(255,255,255,.22) 0%, rgba(255,255,255,0) 38%),
    /* bottom corner shade */
    radial-gradient(120% 100% at 50% 115%, rgba(0,0,0,.26) 0%, rgba(0,0,0,0) 60%),
    /* main color */
    linear-gradient(135deg, rgba(34,211,238,.62), rgba(34,211,238,.16));
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.18),
    inset 0 -10px 16px rgba(0,0,0,.22),
    inset 0 0 0 1px rgba(255,255,255,.14),
    0 0 12px rgba(34,211,238,.18);
}

.cell.filled.kind-O{
  background:
    linear-gradient(180deg, rgba(255,255,255,.22) 0%, rgba(255,255,255,0) 38%),
    radial-gradient(120% 100% at 50% 115%, rgba(0,0,0,.26) 0%, rgba(0,0,0,0) 60%),
    linear-gradient(135deg, rgba(250,204,21,.64), rgba(250,204,21,.16));
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.18),
    inset 0 -10px 16px rgba(0,0,0,.22),
    inset 0 0 0 1px rgba(255,255,255,.14),
    0 0 12px rgba(250,204,21,.16);
}

.cell.filled.kind-T{
  background:
    linear-gradient(180deg, rgba(255,255,255,.22) 0%, rgba(255,255,255,0) 38%),
    radial-gradient(120% 100% at 50% 115%, rgba(0,0,0,.26) 0%, rgba(0,0,0,0) 60%),
    linear-gradient(135deg, rgba(168,85,247,.64), rgba(168,85,247,.16));
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.18),
    inset 0 -10px 16px rgba(0,0,0,.22),
    inset 0 0 0 1px rgba(255,255,255,.14),
    0 0 12px rgba(168,85,247,.16);
}

.cell.filled.kind-S{
  background:
    linear-gradient(180deg, rgba(255,255,255,.22) 0%, rgba(255,255,255,0) 38%),
    radial-gradient(120% 100% at 50% 115%, rgba(0,0,0,.26) 0%, rgba(0,0,0,0) 60%),
    linear-gradient(135deg, rgba(34,197,94,.62), rgba(34,197,94,.16));
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.18),
    inset 0 -10px 16px rgba(0,0,0,.22),
    inset 0 0 0 1px rgba(255,255,255,.14),
    0 0 12px rgba(34,197,94,.14);
}

.cell.filled.kind-Z{
  background:
    linear-gradient(180deg, rgba(255,255,255,.22) 0%, rgba(255,255,255,0) 38%),
    radial-gradient(120% 100% at 50% 115%, rgba(0,0,0,.26) 0%, rgba(0,0,0,0) 60%),
    linear-gradient(135deg, rgba(239,68,68,.64), rgba(239,68,68,.16));
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.18),
    inset 0 -10px 16px rgba(0,0,0,.22),
    inset 0 0 0 1px rgba(255,255,255,.14),
    0 0 12px rgba(239,68,68,.14);
}

.cell.filled.kind-J{
  background:
    linear-gradient(180deg, rgba(255,255,255,.22) 0%, rgba(255,255,255,0) 38%),
    radial-gradient(120% 100% at 50% 115%, rgba(0,0,0,.26) 0%, rgba(0,0,0,0) 60%),
    linear-gradient(135deg, rgba(59,130,246,.64), rgba(59,130,246,.16));
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.18),
    inset 0 -10px 16px rgba(0,0,0,.22),
    inset 0 0 0 1px rgba(255,255,255,.14),
    0 0 12px rgba(59,130,246,.14);
}

.cell.filled.kind-L{
  background:
    linear-gradient(180deg, rgba(255,255,255,.22) 0%, rgba(255,255,255,0) 38%),
    radial-gradient(120% 100% at 50% 115%, rgba(0,0,0,.26) 0%, rgba(0,0,0,0) 60%),
    linear-gradient(135deg, rgba(249,115,22,.64), rgba(249,115,22,.16));
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.18),
    inset 0 -10px 16px rgba(0,0,0,.22),
    inset 0 0 0 1px rgba(255,255,255,.14),
    0 0 12px rgba(249,115,22,.14);
}

/* ===== Glass block (visual-only) ===== */

.cell.filled.kind-G{
  background:
    /* top glass highlight */
    linear-gradient(
      180deg,
      rgba(255,255,255,.38) 0%,
      rgba(255,255,255,.18) 28%,
      rgba(255,255,255,0) 55%
    ),
    /* inner glow */
    radial-gradient(
      120% 120% at 30% 20%,
      rgba(180,220,255,.45),
      rgba(120,180,255,.18) 40%,
      rgba(120,180,255,0) 65%
    ),
    /* base glass tint */
    linear-gradient(
      135deg,
      rgba(120,190,255,.35),
      rgba(120,190,255,.12)
    );
  border: 1px solid rgba(180,220,255,.55);
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.45),
    inset 0 -12px 22px rgba(0,0,0,.18),
    inset 0 0 0 1px rgba(255,255,255,.22),
    0 0 16px rgba(140,200,255,.22);
}

    /* ===== 1x1 Text blocks (pretty) ===== */
.cell.filled.kind-A,
.cell.filled.kind-Q,
.cell.filled.kind-X,
.cell.filled.kind-P,
.cell.filled.kind-K{
  position: relative;
  border: 1px solid rgba(255,255,255,.14);
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.20),
    inset 0 -12px 22px rgba(0,0,0,.22),
    0 0 14px rgba(255,255,255,.10);
  overflow: hidden;
}

/* subtle ‚Äúpaper + neon‚Äù feels */
.cell.filled.kind-A{ /* Â§© */
  background:
    radial-gradient(120% 120% at 30% 18%, rgba(255,255,255,.28), rgba(255,255,255,0) 58%),
    linear-gradient(135deg, rgba(56,189,248,.58), rgba(14,165,233,.16));
}
.cell.filled.kind-Q{ /* Êô¥ */
  background:
    radial-gradient(120% 120% at 30% 18%, rgba(255,255,255,.28), rgba(255,255,255,0) 58%),
    linear-gradient(135deg, rgba(250,204,21,.58), rgba(202,138,4,.18));
}
.cell.filled.kind-X{ /* Â∞è */
  background:
    radial-gradient(120% 120% at 30% 18%, rgba(255,255,255,.28), rgba(255,255,255,0) 58%),
    linear-gradient(135deg, rgba(168,85,247,.56), rgba(126,34,206,.16));
}
.cell.filled.kind-P{ /* ÂÆù */
  background:
    radial-gradient(120% 120% at 30% 18%, rgba(255,255,255,.28), rgba(255,255,255,0) 58%),
    linear-gradient(135deg, rgba(34,197,94,.56), rgba(22,163,74,.16));
}
.cell.filled.kind-K{ /* Ë¥ù */
  background:
    radial-gradient(120% 120% at 30% 18%, rgba(255,255,255,.28), rgba(255,255,255,0) 58%),
    linear-gradient(135deg, rgba(244,63,94,.54), rgba(190,18,60,.16));
}

/* the character */
.cell.filled.kind-A::after,
.cell.filled.kind-Q::after,
.cell.filled.kind-X::after,
.cell.filled.kind-P::after,
.cell.filled.kind-K::after{
  position: absolute;
  inset: 0;
  display: grid;
  place-items: center;
  font-weight: 950;
  font-size: 15px;
  letter-spacing: .5px;
  color: rgba(255,255,255,.92);
  text-shadow:
    0 0 10px rgba(255,255,255,.22),
    0 10px 18px rgba(0,0,0,.40);
  opacity: .92;
  pointer-events: none;
}

.cell.filled.kind-A::after{ content: "Â§©"; }
.cell.filled.kind-Q::after{ content: "Êô¥"; }
.cell.filled.kind-X::after{ content: "Â∞è"; }
.cell.filled.kind-P::after{ content: "ÂÆù"; }
.cell.filled.kind-K::after{ content: "Ë¥ù"; }

    /* ===== Energy block (E) ===== */
.cell.filled.kind-E{
  position: relative;
  background:
    /* moving-ish highlight feel (static but looks energetic) */
    radial-gradient(120% 120% at 30% 18%, rgba(255,255,255,.28), rgba(255,255,255,0) 58%),
    radial-gradient(140% 140% at 70% 30%, rgba(168,85,247,.42), rgba(168,85,247,0) 60%),
    linear-gradient(135deg, rgba(59,130,246,.70), rgba(168,85,247,.18));
  border: 1px solid rgba(170,140,255,.58);
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.22),
    inset 0 -12px 22px rgba(0,0,0,.22),
    0 0 18px rgba(168,85,247,.22);
  animation: energyPulse 1.05s ease-in-out infinite;
}

.cell.filled.kind-E::after{
  content: "‚ö°";
  position: absolute;
  inset: 0;
  display: grid;
  place-items: center;
  font-size: 15px;
  font-weight: 900;
  color: rgba(255,255,255,.78);
  text-shadow:
    0 0 10px rgba(168,85,247,.35),
    0 10px 18px rgba(0,0,0,.35);
  opacity: .85;
  pointer-events: none;
}

@keyframes energyPulse{
  0%,100%{ filter: brightness(1.02) saturate(1.05); transform: translateZ(0); }
  50%    { filter: brightness(1.18) saturate(1.20); transform: translateZ(0); }
}

/* ===== Bomb / Pulse block (B) ===== */
.cell.filled.kind-B{
  position: relative;
  background:
    radial-gradient(120% 120% at 30% 18%, rgba(255,255,255,.22), rgba(255,255,255,0) 58%),
    radial-gradient(140% 140% at 70% 30%, rgba(248,113,113,.42), rgba(248,113,113,0) 62%),
    linear-gradient(135deg, rgba(239,68,68,.72), rgba(244,63,94,.18));
  border: 1px solid rgba(255,255,255,.10);
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.18),
    inset 0 -12px 22px rgba(0,0,0,.24),
    0 0 18px rgba(239,68,68,.16);
  animation: bombBreath 1.15s ease-in-out infinite;
}

.cell.filled.kind-B::after{
  content: "";
  position: absolute;
  left: 50%;
  top: 50%;
  width: 8px;
  height: 8px;
  border-radius: 999px;
  transform: translate(-50%, -50%);
  background: rgba(255,255,255,.88);
  box-shadow:
    0 0 10px rgba(255,255,255,.28),
    0 0 18px rgba(239,68,68,.22);
  opacity: .90;
  pointer-events: none;
}

@keyframes bombBreath{
  0%,100%{ filter: brightness(1.02) saturate(1.05); transform: translateZ(0) scale(1); }
  50%    { filter: brightness(1.18) saturate(1.15); transform: translateZ(0) scale(1.04); }
}

/* Bomb blast ring (separate effect from line clear) */
  .bomb-blast{
    position: absolute;
    width: calc(var(--cell) * 2.6);
    height: calc(var(--cell) * 2.6);
    border-radius: 999px;
    left: var(--bx);
    top: var(--by);
    transform: translate(-50%, -50%) scale(.35);
    pointer-events: none;
    z-index: 6;
    background:
      radial-gradient(circle at 50% 50%, rgba(255,255,255,.18) 0%, rgba(255,255,255,0) 45%),
      radial-gradient(circle at 50% 50%, rgba(239,68,68,.28) 0%, rgba(239,68,68,0) 60%);
    box-shadow: 0 0 30px rgba(239,68,68,.18);
    animation: bombBlast 1.25s ease-out forwards;
    mix-blend-mode: screen;
  }

@keyframes bombBlast{
  0%   { opacity: 0;   transform: translate(-50%, -50%) scale(.20); filter: blur(2px); }
  25%  { opacity: .9; transform: translate(-50%, -50%) scale(.55); filter: blur(0px); }
  60%  { opacity: .6; transform: translate(-50%, -50%) scale(.95); filter: blur(1px); }
  100% { opacity: 0;  transform: translate(-50%, -50%) scale(1.35); filter: blur(3px); }
}

    /* ===== Ice block (C) ===== */
.cell.filled.kind-C{
  position: relative;
  background:
    linear-gradient(180deg, rgba(255,255,255,.26) 0%, rgba(255,255,255,0) 40%),
    radial-gradient(120% 120% at 30% 18%, rgba(255,255,255,.22), rgba(255,255,255,0) 58%),
    linear-gradient(135deg, rgba(56,189,248,.60), rgba(14,165,233,.16));
  border: 1px solid rgba(180,230,255,.40);
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.22),
    inset 0 -14px 22px rgba(0,0,0,.22),
    0 0 16px rgba(56,189,248,.14);
}
/* crack texture */
.cell.filled.kind-C::after{
  content: "";
  position: absolute;
  inset: 1px;
  border-radius: 4px;
  opacity: .55;
  pointer-events: none;
  background:
    repeating-linear-gradient(55deg,
      rgba(255,255,255,0) 0px,
      rgba(255,255,255,0) 6px,
      rgba(255,255,255,.22) 7px,
      rgba(255,255,255,0) 9px),
    repeating-linear-gradient(125deg,
      rgba(255,255,255,0) 0px,
      rgba(255,255,255,0) 8px,
      rgba(255,255,255,.18) 9px,
      rgba(255,255,255,0) 11px);
  mix-blend-mode: overlay;
}
/* snowflake marker */
.cell.filled.kind-C::before{
  content: "‚ùÑ";
  position: absolute;
  inset: 0;
  display: grid;
  place-items: center;
  font-size: 14px;
  font-weight: 900;
  color: rgba(255,255,255,.74);
  text-shadow:
    0 0 10px rgba(56,189,248,.24),
    0 10px 18px rgba(0,0,0,.32);
  opacity: .70;
  pointer-events: none;
}
    /* ===== Metal block (M) ===== */
/* Dark metal (first life) */
.cell.filled.kind-M{
  background:
    linear-gradient(180deg, rgba(255,255,255,.20) 0%, rgba(255,255,255,0) 40%),
    radial-gradient(140% 120% at 30% 18%, rgba(255,255,255,.12), rgba(255,255,255,0) 58%),
    linear-gradient(135deg, rgba(180,190,205,.55), rgba(85,95,110,.22));
  border: 1px solid rgba(255,255,255,.16);
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.22),
    inset 0 -16px 24px rgba(0,0,0,.28),
    inset 0 0 0 1px rgba(255,255,255,.10),
    0 0 10px rgba(180,190,205,.10);
}

/* Hex-nut marker for dark metal */
.cell.filled.kind-M::after{
  content: "‚¨°";
  position: absolute;
  inset: 0;
  display: grid;
  place-items: center;
  font-size: 14px;
  font-weight: 900;
  color: rgba(230,235,245,.55);
  text-shadow:
    0 0 6px rgba(255,255,255,.18),
    0 6px 12px rgba(0,0,0,.45);
  opacity: .75;
  pointer-events: none;
}

/* Light metal (second life) */
.cell.filled.kind-R{
  background:
    linear-gradient(180deg, rgba(255,255,255,.32) 0%, rgba(255,255,255,0) 40%),
    radial-gradient(140% 120% at 30% 18%, rgba(255,255,255,.22), rgba(255,255,255,0) 60%),
    linear-gradient(135deg, rgba(210,218,230,.62), rgba(120,130,145,.22));
  border: 1px solid rgba(255,255,255,.22);
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.28),
    inset 0 -14px 22px rgba(0,0,0,.24),
    inset 0 0 0 1px rgba(255,255,255,.14),
    0 0 12px rgba(210,218,230,.12);
}

/* Hex-nut marker for light metal */
.cell.filled.kind-R::after{
  content: "‚¨°";
  position: absolute;
  inset: 0;
  display: grid;
  place-items: center;
  font-size: 14px;
  font-weight: 900;
  color: rgba(255,255,255,.85);
  text-shadow:
    0 0 10px rgba(255,255,255,.35),
    0 6px 14px rgba(0,0,0,.35);
  opacity: .9;
  pointer-events: none;
}

/* Keep ghost readable over colors */
.cell.ghost{
  background: rgba(255,255,255,.03);
  border: 1px dashed rgba(255,255,255,.20);
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.10);
  opacity: .62;
}
/* Ghost tint by piece kind */
.cell.ghost.kind-I{ border-color: rgba(34,211,238,.32); box-shadow: inset 0 0 0 2px rgba(34,211,238,.28), 0 0 10px rgba(34,211,238,.08); }
.cell.ghost.kind-O{ border-color: rgba(250,204,21,.32); box-shadow: inset 0 0 0 2px rgba(250,204,21,.28), 0 0 10px rgba(250,204,21,.07); }
.cell.ghost.kind-T{ border-color: rgba(168,85,247,.32); box-shadow: inset 0 0 0 2px rgba(168,85,247,.28), 0 0 10px rgba(168,85,247,.07); }
.cell.ghost.kind-S{ border-color: rgba(34,197,94,.30); box-shadow: inset 0 0 0 2px rgba(34,197,94,.26), 0 0 10px rgba(34,197,94,.06); }
.cell.ghost.kind-Z{ border-color: rgba(239,68,68,.30); box-shadow: inset 0 0 0 2px rgba(239,68,68,.26), 0 0 10px rgba(239,68,68,.06); }
.cell.ghost.kind-J{ border-color: rgba(59,130,246,.30); box-shadow: inset 0 0 0 2px rgba(59,130,246,.26), 0 0 10px rgba(59,130,246,.06); }
.cell.ghost.kind-L{ border-color: rgba(249,115,22,.30); box-shadow: inset 0 0 0 2px rgba(249,115,22,.26), 0 0 10px rgba(249,115,22,.06); }
    .cell.ghost.kind-E{ border-color: rgba(168,85,247,.34); box-shadow: inset 0 0 0 2px rgba(168,85,247,.26), 0 0 10px rgba(168,85,247,.08); }
.cell.ghost.kind-A{ border-color: rgba(56,189,248,.34); box-shadow: inset 0 0 0 2px rgba(56,189,248,.26), 0 0 10px rgba(56,189,248,.08); }
.cell.ghost.kind-Q{ border-color: rgba(250,204,21,.34); box-shadow: inset 0 0 0 2px rgba(250,204,21,.26), 0 0 10px rgba(250,204,21,.08); }
.cell.ghost.kind-X{ border-color: rgba(168,85,247,.34); box-shadow: inset 0 0 0 2px rgba(168,85,247,.26), 0 0 10px rgba(168,85,247,.08); }
.cell.ghost.kind-P{ border-color: rgba(34,197,94,.32); box-shadow: inset 0 0 0 2px rgba(34,197,94,.26), 0 0 10px rgba(34,197,94,.07); }
.cell.ghost.kind-K{ border-color: rgba(244,63,94,.32); box-shadow: inset 0 0 0 2px rgba(244,63,94,.26), 0 0 10px rgba(244,63,94,.07); }
    .cell.next{
  border:none;
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.10);
  background: linear-gradient(135deg, rgba(255,255,255,.10), rgba(255,255,255,.03));
  opacity: .32;
}

    /* Next preview tint by piece kind (Step 10) */
    .cell.next.kind-I{ background: linear-gradient(135deg, rgba(34,211,238,.22), rgba(34,211,238,.06)); }
    .cell.next.kind-O{ background: linear-gradient(135deg, rgba(250,204,21,.22), rgba(250,204,21,.06)); }
    .cell.next.kind-T{ background: linear-gradient(135deg, rgba(168,85,247,.22), rgba(168,85,247,.06)); }
    .cell.next.kind-S{ background: linear-gradient(135deg, rgba(34,197,94,.20), rgba(34,197,94,.06)); }
    .cell.next.kind-Z{ background: linear-gradient(135deg, rgba(239,68,68,.20), rgba(239,68,68,.06)); }
    .cell.next.kind-J{ background: linear-gradient(135deg, rgba(59,130,246,.20), rgba(59,130,246,.06)); }
    .cell.next.kind-L{ background: linear-gradient(135deg, rgba(249,115,22,.20), rgba(249,115,22,.06)); }
    .cell.next.kind-E{ background: linear-gradient(135deg, rgba(168,85,247,.22), rgba(168,85,247,.06)); }
    .cell.next.kind-A{ background: linear-gradient(135deg, rgba(56,189,248,.22), rgba(56,189,248,.06)); }
    .cell.next.kind-Q{ background: linear-gradient(135deg, rgba(250,204,21,.22), rgba(250,204,21,.06)); }
    .cell.next.kind-X{ background: linear-gradient(135deg, rgba(168,85,247,.22), rgba(168,85,247,.06)); }
    .cell.next.kind-P{ background: linear-gradient(135deg, rgba(34,197,94,.20), rgba(34,197,94,.06)); }
    .cell.next.kind-K{ background: linear-gradient(135deg, rgba(244,63,94,.20), rgba(244,63,94,.06)); }

    .side{
      display:flex;
      flex-direction:column;
      gap:12px;
      padding:10px 12px;
    }
    .card{
      background: rgba(16,24,39,.55);
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
      padding:12px;

      margin-left: auto;
  margin-right: auto;
  width: 100%;
    }

    /* ===== Side hierarchy: primary card vs tips card ===== */
    .card.primary{
      background: rgba(16,24,39,.78);
      border-color: rgba(var(--accent-rgb), .28);
      box-shadow: 0 16px 36px rgba(0,0,0,.35), 0 0 0 1px rgba(var(--accent-rgb), .10);
    }

    .card.primary .title{
      letter-spacing: .9px;
    }

    .card.tips{
      background: rgba(16,24,39,.38);
      border-color: rgba(255,255,255,.06);
      padding: 10px 12px;
      opacity: .86;
    }

    .card.tips .title{
      font-size: 13px;
      opacity: .85;
      margin-bottom: 4px;
    }

    .card.tips .hint{
      font-size: 12px;
      line-height: 1.5;
      color: rgba(148,163,184,.92);
    }
    .title{
      font-weight:800;
      letter-spacing:.5px;
      margin:0 0 6px 0;
    }
    .row{
      display:flex;
      justify-content:space-between;
      margin:6px 0;
      color:var(--muted);
      font-size:14px;
    }
    .row b{color:var(--text); font-weight:700}
    .hint{
      font-size:13px;
      color:var(--muted);
      line-height:1.45;
    }
    .btns{
      display:grid;
      grid-template-columns: repeat(2, 1fr);
      gap:10px;
      margin-top:10px;
    }
    button{
      border:none;
      border-radius:12px;
      padding:10px 12px;
      font-weight:700;
      cursor:pointer;
      background: linear-gradient(180deg, rgba(255,255,255,.14), rgba(255,255,255,.06));
      color:var(--text);
      border:1px solid rgba(255,255,255,.10);

      /* smoother, unified feel */
      transform: translateY(0);
      transition:
        border-color .16s ease,
        background .16s ease,
        box-shadow .16s ease,
        transform .12s ease,
        filter .16s ease;
      will-change: transform;
    }
    button:active{
      transform: translateY(1px);
      filter: brightness(.98);
      box-shadow: none;
    }
    /* ===== Button states (Step 8) ===== */
    button:hover{
      border-color: rgba(var(--accent-rgb, 34,211,238), .35);
      filter: brightness(1.06);
      transform: translateY(-1px);
      box-shadow: 0 12px 28px rgba(0,0,0,.28);
    }
    button.active{
      border-color: rgba(var(--accent-rgb, 34,211,238), .60);
      box-shadow: 0 0 0 2px rgba(var(--accent-rgb, 34,211,238), .18), 0 10px 25px rgba(0,0,0,.25);
      background: linear-gradient(135deg, rgba(var(--accent-rgb, 34,211,238), .22), rgba(255,255,255,.06));
      transform: translateY(-1px);
    }
    button.danger{
      border-color: rgba(239,68,68,.35);
    }
    button.danger:hover{
      border-color: rgba(239,68,68,.55);
    }
    .overlay{
      position:absolute; inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:none;
      z-index: 5;
      font-size:28px;
      font-weight:900;
      letter-spacing:1px;
      text-shadow: 0 10px 30px rgba(0,0,0,.6);
      background: rgba(2,6,23,.35);
      opacity:0;
      transition: .15s;
    }
    .overlay.show{opacity:1}

    /* ===== In-board Pause button (top-right) ===== */
    .pause-corner{
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 7; /* above HUD (z=4) and below modals */

      width: 44px;
      height: 44px;
      border-radius: 14px;

      display: grid;
      place-items: center;
      font-size: 18px;
      font-weight: 900;

      /* transparent but obvious */
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.18);
      color: var(--text);

      box-shadow:
        0 14px 28px rgba(0,0,0,.34),
        inset 0 1px 0 rgba(255,255,255,.16);
      backdrop-filter: blur(8px);
      -webkit-tap-highlight-color: transparent;

      cursor: pointer;
      transition:
        transform .12s ease,
        filter .14s ease,
        border-color .14s ease,
        background .14s ease,
        box-shadow .14s ease;
    }

    .pause-corner:hover{
      filter: brightness(1.08);
      border-color: rgba(var(--accent-rgb), .45);
      background: rgba(255,255,255,.14);
      transform: translateY(-1px);
      box-shadow:
        0 16px 34px rgba(0,0,0,.36),
        inset 0 1px 0 rgba(255,255,255,.18);
    }

    .pause-corner:active{
      transform: translateY(0px) scale(.96);
      filter: brightness(.96);
      box-shadow:
        0 10px 20px rgba(0,0,0,.30),
        inset 0 1px 0 rgba(255,255,255,.10);
    }

    /* phone: keep it slightly larger for touch */
    @media (max-width: 600px){
      .pause-corner{
        width: 48px;
        height: 48px;
        border-radius: 16px;
        font-size: 19px;
      }
    }
    @media (max-width: 860px){
      .wrap{grid-template-columns: 1fr; width:min(520px, 92vw)}
      .side{flex-direction:row; flex-wrap:wrap}
      .side .card{flex:1 1 220px}
      :root{--cell: 24px}
    }
    /* ‰∏ªÈ°µÈù¢ÈöêËóèÊöÇÂÅúÊåâÈíÆ */
.pause-corner.hidden{
  display: none;
}

    /* ===== Mobile touch controls ===== */
    .mctl{
      position: fixed;
      left: 50%;
      bottom: 14px;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      padding: 10px;
      border-radius: 16px;
      background: rgba(2,6,23,.35);
      border: 1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(10px);
      z-index: 9999;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      touch-action: manipulation;
    }
    .mbtn{
      min-width: 52px;
      height: 48px;
      border-radius: 14px;
      font-weight: 900;
      letter-spacing: .3px;
      -webkit-appearance: none;
      appearance: none;
      position: relative;
      overflow: hidden;

      /* layered ‚Äúkeycap‚Äù look */
      border: 1px solid rgba(255,255,255,.22);
      background:
        radial-gradient(140% 120% at 30% 18%, rgba(255,255,255,.30), rgba(255,255,255,0) 58%),
        linear-gradient(180deg, rgba(255,255,255,.22), rgba(255,255,255,.07));
      color: var(--text);

      /* depth */
      box-shadow:
        inset 0 2px 0 rgba(255,255,255,.20),
        0 16px 34px rgba(0,0,0,.36),
        inset 0 1px 0 rgba(255,255,255,.18),
        inset 0 -14px 22px rgba(0,0,0,.30);

      padding: 0 14px;
      transition:
        transform .10s ease,
        filter .12s ease,
        border-color .14s ease,
        background .14s ease,
        box-shadow .14s ease;
      transform: translateY(0);
      will-change: transform;
      -webkit-tap-highlight-color: transparent;
      text-shadow: 0 10px 22px rgba(0,0,0,.40);
    }

    /* Visible sheen layer (helps on iOS where gradients can look flat) */
    .mbtn::after{
      content:"";
      position:absolute;
      inset:-1px;
      border-radius: inherit;
      pointer-events:none;
      background: linear-gradient(135deg,
        rgba(255,255,255,.34) 0%,
        rgba(255,255,255,.10) 22%,
        rgba(255,255,255,0) 55%);
      opacity: .60;
      mix-blend-mode: normal;
    }

    .mbtn:active::after{ opacity: .14; }
    .mbtn.active::after{ opacity: .44; }
    .mbtn.active{
      border-color: rgba(var(--accent-rgb, 34,211,238), .62);
      background:
        radial-gradient(140% 120% at 30% 18%, rgba(var(--accent-rgb, 34,211,238), .34), rgba(255,255,255,0) 60%),
        linear-gradient(180deg, rgba(255,255,255,.22), rgba(255,255,255,.08));
      box-shadow:
        0 0 0 2px rgba(var(--accent-rgb, 34,211,238), .16),
        0 14px 30px rgba(0,0,0,.28),
        inset 0 1px 0 rgba(255,255,255,.12),
        inset 0 -10px 18px rgba(0,0,0,.22);
      filter: brightness(1.06);
    }
    .mbtn.wide{ min-width: 92px; }
    .mbtn:active{
      transform: translateY(1px) scale(.965);
      filter: brightness(.96);
      box-shadow:
        0 8px 16px rgba(0,0,0,.26),
        inset 0 1px 0 rgba(255,255,255,.08),
        inset 0 -12px 22px rgba(0,0,0,.28);
    }

    /* Hover polish (desktop click users) */
    @media (hover:hover){
      .mbtn:hover{
        filter: brightness(1.06);
        border-color: rgba(var(--accent-rgb, 34,211,238), .32);
        box-shadow:
          0 16px 34px rgba(0,0,0,.32),
          inset 0 1px 0 rgba(255,255,255,.12),
          inset 0 -10px 18px rgba(0,0,0,.22);
        transform: translateY(-1px);
      }
    }

    /* Make DROP look like a ‚Äúspecial‚Äù button without changing its size */
    .mbtn[data-act="drop"]{
      border-color: rgba(255,255,255,.18);
      background:
        radial-gradient(140% 120% at 30% 18%, rgba(255,255,255,.36), rgba(255,255,255,0) 60%),
        linear-gradient(180deg, rgba(255,255,255,.26), rgba(255,255,255,.10));
      box-shadow:
        0 18px 40px rgba(0,0,0,.34),
        inset 0 1px 0 rgba(255,255,255,.14),
        inset 0 -12px 22px rgba(0,0,0,.26);
      letter-spacing: .9px;
    }

    /* ===== Game-style colored controls (ONLY color, no layout change) ===== */

    /* Â∑¶Áßª */
    .mbtn[data-act="left"]{
      background:
        radial-gradient(140% 120% at 30% 18%, rgba(59,130,246,.45), rgba(59,130,246,0) 60%),
        linear-gradient(180deg, rgba(59,130,246,.35), rgba(37,99,235,.18));
      border-color: rgba(59,130,246,.55);
    }

    /* Âè≥Áßª */
    .mbtn[data-act="right"]{
      background:
        radial-gradient(140% 120% at 30% 18%, rgba(96,165,250,.45), rgba(96,165,250,0) 60%),
        linear-gradient(180deg, rgba(96,165,250,.35), rgba(37,99,235,.18));
      border-color: rgba(96,165,250,.55);
    }

    /* ËΩØÈôç */
    .mbtn[data-act="down"]{
      background:
        radial-gradient(140% 120% at 30% 18%, rgba(34,197,94,.45), rgba(34,197,94,0) 60%),
        linear-gradient(180deg, rgba(34,197,94,.35), rgba(22,163,74,.18));
      border-color: rgba(34,197,94,.55);
    }

    /* ÊóãËΩ¨ */
    .mbtn[data-act="rotate"]{
      background:
        radial-gradient(140% 120% at 30% 18%, rgba(168,85,247,.45), rgba(168,85,247,0) 60%),
        linear-gradient(180deg, rgba(168,85,247,.35), rgba(126,34,206,.18));
      border-color: rgba(168,85,247,.55);
    }

    /* Á°¨Èôç / DROPÔºà‰∏ªÊåâÈíÆÔºâ */
    .mbtn[data-act="drop"]{
      background:
        radial-gradient(140% 120% at 30% 18%, rgba(250,204,21,.55), rgba(250,204,21,0) 60%),
        linear-gradient(180deg, rgba(250,204,21,.38), rgba(202,138,4,.22));
      border-color: rgba(250,204,21,.65);
    }

    .mbtn[data-act="drop"]:active{
      transform: translateY(1px) scale(.955);
    }

    /* Subtle icon clarity for arrow/rotate */
    .mbtn[data-act="left"],
    .mbtn[data-act="right"],
    .mbtn[data-act="down"],
    .mbtn[data-act="rotate"]{
      font-size: 18px;
      text-shadow: 0 10px 22px rgba(0,0,0,.35);
    }

    @media (max-width: 520px){
      .mbtn{ min-width: 56px; height: 52px; font-size: 16px; }
      .mbtn.wide{ min-width: 104px; }
    }
    /* ===== Fix mobile alignment ===== */
    @media (max-width: 600px) {
  .side .card{
    padding: 10px 12px;
    margin-left: auto;
    margin-right: auto;
    width: 100%;
  }

  /* Á°Æ‰øù‚ÄúÂêÑÁßçÊ®°ÂºèÊåâÈíÆÂå∫‚Äù‰∏ç‰∫ßÁîüÊ®™ÂêëÊ∫¢Âá∫ */
  .side .btns{ width: 100%; }
  .side .btns button{ width: 100%; }
  /* Make the board as large as the phone width/height allows */
  :root{
    /* Fit by width */
    --cellW: calc((100vw - 28px - var(--gap) * 9) / 10);
    /* Fit by height: viewport height minus safe areas and reserved controls space */
    --cellH: calc((100svh - env(safe-area-inset-top) - 14px - var(--mctl-pad, 0px) - env(safe-area-inset-bottom) - var(--gap) * 19) / 20);
    /* Choose the smaller one so the whole board fits */
    --cell: clamp(16px, min(var(--cellW), var(--cellH)), 30px);
  }

  body {
    justify-content: center;
  align-items: center;
  min-height: 100svh;
  padding: calc(10px + env(safe-area-inset-top)) 8px calc(var(--mctl-pad, 0px) + env(safe-area-inset-bottom));
  }
/* Show the stats panel under the board on phone (keep board/control sizes the same) */
.side{
  display: flex;
  flex-direction: column;
  width: 100%;
  max-width: 560px;
  padding: 0;
  gap: 10px;
  margin-top: 10px;
  margin-left: auto;
  margin-right: auto;
}

/* Only keep the first TETRIS stats card on phone */
.side .card:nth-child(2){ display:none; }

/* Make the stats card compact */
.side .card{
  padding: 10px 12px;
}
.side .row{ font-size: 13px; }
  .wrap {
    grid-template-columns: 1fr !important;
    justify-items: center;
    width: 100%;
max-width: 560px;
    padding: 12px;
    gap: 10px;
    margin-bottom: 0;
    margin-left: auto;
  margin-right: auto;
  }

  .board{
  margin: 0;
  justify-self: center;
  place-self: center;   /* ‚≠ê ÂÖ≥ÈîÆÔºöÂêåÊó∂ÊéßÂà∂Ê®™Âêë + Á∫µÂêë */
}

  /* ===== Mobile controls layout (phone only) ===== */
  .mctl{
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  z-index: 9999;

  --btn: clamp(52px, 14vw, 66px);
  --drop: clamp(110px, 30vw, 150px);

  display: grid;
  grid-template-columns: var(--btn) var(--btn) var(--btn) var(--btn) var(--drop);
  grid-template-rows: auto auto;

  gap: 6px;
  padding: 20px;

  width: calc(100vw - 16px);
  max-width: calc(100vw - 16px);

  justify-items: center;
  align-items: center;
  touch-action: none;

  bottom: calc(env(safe-area-inset-bottom) + 0px);
}
  .mctl .mbtn[data-act="left"]{ grid-column: 1; grid-row: 1; }
  .mctl .mbtn[data-act="right"]{ grid-column: 3; grid-row: 1; }
  .mctl .mbtn[data-act="down"]{ grid-column: 2; grid-row: 2; }
  /* ËÆ©Â∑¶Âè≥ÈîÆ‚ÄúÂè™ÂæÄ‰∏≠Èó¥ÂèòÂÆΩ‚ÄùÔºåÂ§ñ‰æßËæπ‰∏çÂä® */
.mctl{
  --lrGrow: 15px; /* ÂæÆË∞ÉÔºö4pxÊõ¥Â∞èÔºå8pxÂàöÂ•ΩÔºå12pxÊõ¥ÊòéÊòæ */
}

.mctl .mbtn[data-act="left"]{
  justify-self: start;                 /* ÈîöÂÆöÂ∑¶Ëæπ */
  width: calc(var(--btn) + var(--lrGrow));
}

.mctl .mbtn[data-act="right"]{
  justify-self: end;                   /* ÈîöÂÆöÂè≥Ëæπ */
  width: calc(var(--btn) + var(--lrGrow));
}

  .mctl .mbtn[data-act="rotate"]{
  grid-column: 4;
  grid-row: 1 / 3;                 /* Ë∑®‰∏§Ë°åÔºö‰ªéÁ¨¨‰∏ÄË°å‰∏ÄÁõ¥Âà∞Á¨¨‰∫åË°å */
  height: calc(56px * 2 + 6px);    /* ‰∏§Ë°åÊåâÈíÆÈ´òÂ∫¶ + ‰∏≠Èó¥ gapÔºà‰Ω†Áé∞Âú® gap ÊòØ 6pxÔºâ */
  align-self: stretch;
}
.mctl .mbtn.wide[data-act="drop"]{
  grid-column: 5;
  grid-row: 1 / 3;                 /* Ë∑®‰∏§Ë°åÔºöÂíå rotate„ÄÅ‚¨á ‰∏ÄÊ†∑È´ò */
  height: calc(56px * 2 + 6px);    /* ‰∏§Ë°åÊåâÈíÆÈ´òÂ∫¶ + gapÔºà‰Ω†Áé∞Âú® gap ÊòØ 6pxÔºâ */
  align-self: stretch;
}

  .mctl .mbtn[data-act="pause"]{ display: none; }
    /* bigger touch buttons on phone */
    .mbtn{ min-width: var(--btn); height: 56px; font-size: 18px; padding: 0 10px; }
    .mbtn.wide{ min-width: var(--drop); }
}
/* ===== Mercy Modal ===== */
.modal{
  position: fixed;
  inset: 0;
  width: 100vw;
  height: 100svh; /* iOS/PWA Êõ¥Á®≥ÁöÑËßÜÂè£È´òÂ∫¶ */
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(2,6,23,.55);
  z-index: 10000;

  /* ËÆ©ÈÅÆÁΩ©Êú¨Ë∫´ÂèØÊªöÂä®ÔºàÂ∞èÂ±èÂÜÖÂÆπË∂ÖÈ´òÊó∂Ôºâ */
  overflow: auto;

  /* ÂÆâÂÖ®Âå∫ + ËæπË∑ù */
  padding:
    calc(12px + env(safe-area-inset-top))
    12px
    calc(12px + env(safe-area-inset-bottom))
    12px;
  opacity: 0;
  visibility: hidden;
  pointer-events: none;
  transition: opacity .22s ease, visibility 0s linear .22s;
}

.modal.show{
  opacity: 1;
  visibility: visible;
  pointer-events: auto;
  transition: opacity .22s ease, visibility 0s;
}

.modal-card{
  width: min(520px, 92vw);
  transform: translateY(14px) scale(.98);
  opacity: 0;
  transition: transform .22s cubic-bezier(.2,.8,.2,1), opacity .22s ease;

  /* ÂÖ≥ÈîÆÔºöÈôêÂà∂Âç°ÁâáÈ´òÂ∫¶ÔºåÂπ∂ËÆ©Âç°ÁâáËá™Â∑±ÊªöÂä® */
  max-height: calc(100svh - 24px - env(safe-area-inset-top) - env(safe-area-inset-bottom));
  overflow: auto;

  background: rgba(16,24,39,.92);
  border: 1px solid rgba(255,255,255,.10);
  border-radius: 16px;
  padding: 14px;
  box-shadow: 0 18px 50px rgba(0,0,0,.45);
  backdrop-filter: blur(10px);
}

    .modal.show .modal-card{
  transform: translateY(0) scale(1);
  opacity: 1;
}

@media (prefers-reduced-motion: reduce){
  button, .mbtn, .modal, .modal-card{
    transition: none !important;
    animation: none !important;
  }
}

.modal-title{
  font-weight: 900;
  font-size: 18px;
  margin-bottom: 6px;
}
.modal-desc{
  color: var(--muted);
  font-size: 13px;
  line-height: 1.45;
  margin-bottom: 10px;
}

.modal-input{
  width: 100%;
  height: 44px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.08);
  color: var(--text);
  padding: 0 12px;
  outline: none;
}
.modal-input:focus{
  border-color: rgba(255,255,255,.22);
  background: rgba(255,255,255,.10);
}

.modal-tip{
  margin-top: 8px;
  font-size: 12px;
  color: var(--muted);
}
.modal-tip.bad{ color: #fca5a5; }
.modal-tip.good{ color: #86efac; }

.modal-actions{
  display: flex;
  gap: 10px;
  justify-content: flex-end;
  margin-top: 12px;
}
.modal-btn{
  border-radius: 12px;
  padding: 10px 12px;
  font-weight: 800;
}
.modal-btn.ghost{
  background: rgba(255,255,255,.06);
}
/* ===== Summary Modal ===== */
.summary{
  margin-top: 8px;
}
/* ===== Pause Modal ===== */
.pause-card{
  width: min(86vw, 320px);
  display: grid;
  gap: 14px;
  text-align: center;
}

.pause-title{
  margin-bottom: 6px;
  font-size: 22px;
  font-weight: 900;
  letter-spacing: 1px;
}
.summary .row{
  margin: 8px 0;
  font-size: 14px;
}
.summary small{
  display:block;
  margin-top: 8px;
  color: var(--muted);
  font-size: 12px;
  line-height: 1.4;
}
/* ===== Game Over Toast ===== */
.toast{
  position: fixed;
  left: 50%;
  top: 18%;
  transform: translateX(-50%);
  font-weight: 900;
  font-size: 34px;
  letter-spacing: 2px;
  color: rgba(255,255,255,.95);
  text-shadow: 0 12px 35px rgba(0,0,0,.6);
  opacity: 0;
  pointer-events: none;
  z-index: 15000; /* ÊØîÂºπÁ™ó‰Ωé‰πüË°åÔºå‰ΩÜË¶ÅÊØîÊ∏∏ÊàèÈ´ò */
}
/* Toast color themes */

.toast.combo{ color: rgba(34,211,238,.98); }
.toast.b2b{ color: rgba(168,85,247,.98); }
.toast.pc{ color: rgba(250,204,21,.98); }
.toast.tetris{ color: rgba(255,255,255,.98); }
.toast.metal{ color: rgba(220,228,240,.98); }

.toast.show{
  animation: toastFlash 1.2s ease-out forwards;
}

@keyframes toastFlash{
  0%   { opacity: 0; transform: translateX(-50%) scale(.98); filter: blur(1px); }
  15%  { opacity: 1; transform: translateX(-50%) scale(1.03); filter: blur(0px); }
  55%  { opacity: .9; }
  100% { opacity: 0; transform: translateX(-50%) scale(1.00); filter: blur(2px); }
}
/* ===== Start Screen ===== */
.start{
  position:absolute;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  background: rgba(2,6,23,.55);
  z-index: 6; /* ÊØî overlay È´ò‰∏ÄÁÇπ */
}
.start.show{ display:flex; }

.start-card{
  width: min(360px, 84%);
  padding: 16px;
  border-radius: 16px;
  background: rgba(16,24,39,.92);
  border: 1px solid rgba(255,255,255,.10);
  text-align: center;
  box-shadow: 0 18px 50px rgba(0,0,0,.45);
}
.start-title{
  font-size: 26px;
  font-weight: 900;
  letter-spacing: 2px;
}
.start-sub{
  margin-top: 6px;
  color: var(--muted);
  font-size: 13px;
}
.start-btn{
  margin-top: 12px;
  width: 100%;
  height: 46px;
  border-radius: 14px;
  font-weight: 900;
}
.start-tip{
  margin-top: 10px;
  font-size: 12px;
  color: var(--muted);
}

/* ===== Line clear particles ===== */
.particle{
  position: absolute;
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: rgba(var(--prgb, 255,255,255), .90);
  box-shadow: 0 0 12px rgba(var(--prgb, 255,255,255), .22);
  pointer-events: none;
  animation: particleFly .45s ease-out forwards;
}


@keyframes particleFly{
  from{
    transform: translate(0,0) rotate(var(--rot, 0deg)) scale(1);
    opacity: 1;
  }
  to{
    transform: translate(var(--dx), var(--dy)) rotate(var(--rot, 0deg)) scale(.2);
    opacity: 0;
  }
}
    /* ===== Line clear animation ===== */
/* Clear flash intensity by clear count */
.cell.clearing.clear-1{ filter: brightness(1.6); }
.cell.clearing.clear-2{ filter: brightness(1.9); }
.cell.clearing.clear-3{ filter: brightness(2.15); }
.cell.clearing.clear-4{ filter: brightness(2.35); }
.cell.clearing{
  animation: shatter var(--clear-dur, .28s) cubic-bezier(.2,.8,.2,1) forwards;
  transform-origin: center;
  animation-delay: var(--ad, 0ms);
}
/* ===== Phrase clear (Â§©Êô¥Â∞èÂÆùË¥ù) stronger effect ===== */
.board.phrase-pop{
  animation: phrasePop .42s ease-out;
}
@keyframes phrasePop{
  0%{ filter: brightness(1.0); box-shadow: 0 0 0 0 rgba(var(--accent-rgb), 0); }
  35%{ filter: brightness(1.15); box-shadow: 0 0 0 3px rgba(var(--accent-rgb), .22), 0 0 36px rgba(var(--accent-rgb), .22); }
  100%{ filter: brightness(1.0); box-shadow: 0 0 0 0 rgba(var(--accent-rgb), 0); }
}

.cell.phrase-clearing{
  animation: phraseShatter .32s cubic-bezier(.2,.8,.2,1) forwards;
  transform-origin: center;
  animation-delay: var(--ad, 0ms);
  will-change: transform, opacity, filter;
}

@keyframes phraseShatter{
  0%   { transform: scale(1);    opacity: 1;   filter: brightness(1.05) saturate(1.05); }
  22%  { transform: scale(1.28) rotate(-3deg); opacity: 1;   filter: brightness(1.45) saturate(1.15); }
  65%  { transform: scale(.88) rotate(6deg);  opacity: .45; filter: brightness(1.15) saturate(1.05) blur(.6px); }
  100% { transform: scale(.52) rotate(12deg); opacity: 0;   filter: brightness(1.05) blur(1.4px); }
}
/* ===== Glass-only clear effect (visual-only) ===== */
.cell.clearing.kind-G{
  animation: glassShatter var(--clear-dur, .34s) cubic-bezier(.2,.8,.2,1) forwards;
  filter: brightness(1.25) saturate(1.15);
  animation-delay: var(--ad, 0ms);
}
/* ===== Energy clear: shatter order ===== */
.cell.clearing.energy-first{ --ad: 0ms; }
.cell.clearing.energy-late{  --ad: var(--energy-stagger, 46ms); }

@keyframes glassShatter{
  0%   { transform: scale(1);    opacity: 1;   filter: brightness(1.05) saturate(1.1); }
  18%  { transform: scale(1.28); opacity: 1;   filter: brightness(1.65) saturate(1.25); }
  55%  { transform: scale(.92);  opacity: .55; filter: brightness(1.35) saturate(1.2); }
  100% { transform: scale(.50);  opacity: 0;   filter: brightness(1.10) saturate(1.1); }
}

@keyframes shatter{
  0%   { transform: scale(1);    opacity: 1; }
  20%  { transform: scale(1.22); opacity: 1; }
  60%  { transform: scale(.9);   opacity: .45; }
  100% { transform: scale(.55);  opacity: 0; }
}
/* ===== Faded HUD inside board ===== */
.hud{
  position: absolute;
  left: 14px;
  top: 14px;
  z-index: 4;
  pointer-events: none;
  opacity: .30;
  text-shadow: 0 10px 30px rgba(0,0,0,.55);
}

.hud-row{
  display:flex;
  align-items: baseline;
  gap: 10px;
  font-size: 13px;
color: rgba(229,231,235,.62);
  margin: 6px 0;
}
.hud-row span{
  font-size: 11px;
  letter-spacing: .9px;
  text-transform: uppercase;
  opacity: .75;
}
.hud-row b{
  font-size: 24px;
  font-weight: 950;
  color: rgba(229,231,235,.98);
}

@media (max-width: 520px){
  .hud-row{
    font-size: 12px;
  }
  .hud-row span{
    font-size: 10px;
  }
  .hud-row b{
    font-size: 22px;
  }
}

/* ===== History Modal ===== */
.his-wrap{
    display: grid;
    grid-template-columns: 1fr;
    gap: 10px;
  }
  .his-top{
    display:flex;
    align-items:center;
    justify-content: space-between;
    gap: 10px;
  }
  .his-count{
    color: var(--muted);
    font-size: 12px;
  }
  .his-list{
    max-height: min(52vh, 420px);
    overflow: auto;
    -webkit-overflow-scrolling: touch;
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,.10);
    background: rgba(255,255,255,.04);
  }
  .his-item{
    width: 100%;
    text-align: left;
    display:flex;
    align-items:center;
    justify-content: space-between;
    gap: 10px;
    padding: 10px 12px;
    border: 0;
    background: transparent;
    color: var(--text);
    font-weight: 800;
    border-bottom: 1px solid rgba(255,255,255,.08);
  }
  .his-item:last-child{ border-bottom: 0; }
  .his-item small{
    display:block;
    font-weight: 700;
    color: var(--muted);
    margin-top: 2px;
  }
  .his-item:active{ transform: translateY(1px); }
  .his-detail{
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,.10);
    background: rgba(255,255,255,.04);
    padding: 10px 12px;
  }
  .his-detail .row{ font-size: 14px; }
  .his-actions{
    display:flex;
    gap: 10px;
    justify-content: flex-end;
    flex-wrap: wrap;
  }
  
  @media (min-width: 680px){
    .his-wrap{ grid-template-columns: 1fr 1fr; }
    .his-list{ max-height: min(58vh, 520px); }
  }
  </style>
  
</head>

<body>
  <!-- Splash / Launch Screen -->
<div id="splash" class="splash">
  <div class="splash-card">
    <div class="splash-logo">TETRIS</div>
    <div class="splash-sub">Ê≠£Âú®Âä†ËΩΩ‚Ä¶</div>
    <div class="splash-bar"><i></i></div>
  </div>
</div>
  <div class="wrap">
    <div class="board">
      <div id="grid" class="grid" aria-label="tetris grid"></div>
      <div id="overlay" class="overlay">PAUSED</div>

      <!-- ‚úÖ In-board Pause button (visual only for now) -->
      <button id="pauseCorner" class="pause-corner hidden" aria-label="pause">‚è∏</button>

      <!-- Faded HUD inside the board -->
<div class="hud" aria-hidden="true">
  <div class="hud-row"><span>Score</span><b id="hudScore">0</b></div>
  <div class="hud-row"><span>Level</span><b id="hudLevel">1</b></div>
  <div class="hud-row"><span>Lines</span><b id="hudLines">0</b></div>
  <div class="hud-row"><span>Stage</span><b id="hudStage">1</b></div>
</div>
      <!-- Start Screen -->
  <div id="startScreen" class="start show">
    <div class="start-card">
      <div class="start-title">TETRIS</div>
      <div class="start-sub">ÁÇπÂáªÂºÄÂßãÊ∏∏Êàè</div>
      <button id="btnStart" class="start-btn">ÂºÄÂßãÊ∏∏Êàè ‚ñ∂</button>

<!-- ‚úÖ NEW: Start screen extra buttons -->
<button id="btnStartMode" class="start-btn ghost">ÈÄâÊã©Ê®°Âºè ‚ñæ</button>

<div id="startModeMenu" class="start-menu" hidden>
  <button class="start-menu-item" data-mode="normal">ÊôÆÈÄöÊ®°Âºè üôÇ</button>
  <button class="start-menu-item" data-mode="mercy">Ê±ÇÈ•∂Ê®°Âºè ü•∫</button>
  <button class="start-menu-item" data-mode="pro">Â§ßÁ•ûÊ®°Âºè ‚ö°ÔºàÊÖ¢ÊÖ¢ÂèòÂø´Ôºâ</button>
  <button class="start-menu-item" data-mode="noob">ËèúÈ∏°Ê®°Âºè üê£ÔºàÊÇ¨Á©∫Ëá™Âä®ËêΩÔºâ</button>
  <button class="start-menu-item" data-mode="endless">Êó†Â∞ΩÊ®°Âºè ‚ôæÔ∏èÔºàÁàΩÊ≠ª‰Ω†Ôºâ</button>
</div>

<button id="btnStartHistory" class="start-btn ghost">ÂéÜÂè≤ËÆ∞ÂΩï üóÇÔ∏è</button>
<!-- ‚úÖ NEW END -->

      <div class="start-tip">ÈîÆÁõò / ÊâãÊú∫ÊåâÈîÆÈÉΩÊîØÊåÅ</div>
    </div>
  </div>
    </div>

    <div class="side">
      <div class="card primary">
        <p class="title">TETRIS</p>
        <div class="row"><span>Score</span><b id="score">0</b></div>
        <div class="row"><span>Level</span><b id="level">1</b></div>
        <div class="row"><span>Lines</span><b id="lines">0</b></div>
        <div class="row"><span>Stage</span><b id="stage">1</b></div>
        <div class="btns">
          <button id="btnPause">Pause (P)</button>
          <button id="btnReset">Reset (R)</button>
          <button id="btnNormal">ÊôÆÈÄöÊ®°Âºè üôÇ</button>
          <button id="btnMercy">Ê±ÇÈ•∂Ê®°Âºè ü•∫</button>
          <button id="btnPro">Â§ßÁ•ûÊ®°Âºè ‚ö°ÔºàÊÖ¢ÊÖ¢ÂèòÂø´Ôºâ</button>
          <button id="btnNoob">ËèúÈ∏°Ê®°Âºè üê£ÔºàÊÇ¨Á©∫Ëá™Âä®ËêΩÔºâ</button>
          <button id="btnEndless">Êó†Â∞ΩÊ®°Âºè ‚ôæÔ∏èÔºàÁàΩÊ≠ª‰Ω†Ôºâ</button>
          <button id="btnHistory">ÂéÜÂè≤ËÆ∞ÂΩï üóÇÔ∏è</button>
        </div>
        <p class="hint" style="margin-top:10px">
          ÈîÆÁõòÔºö‚Üê ‚Üí ÁßªÂä®Ôºå‚Üë ÊóãËΩ¨Ôºå‚Üì ËΩØÈôçÔºåSpace Á°¨Èôç<br/>
          P ÊöÇÂÅúÔºåR ÈáçÂºÄ
          ÔºàÊâãÊú∫‰∏ÄÊ†∑ÁöÑÊìç‰ΩúÔºåÁõ∏ÂêåÊåâÈíÆÔºâ666
        </p>
      </div>

      <div class="card tips">
        <p class="title">Tips</p>
        <p class="hint" style="margin:0">
          ‰Ω†Áæ§Âì•ËÄóË¥π‰∏ÄÂë®Á≤æÂøÉÊâìÈÄ†ÔºåÊúâÂï•‰∏ç‰ºöÁöÑÊù•ÈóÆÊàë<br/>
          ÂïäÂìàÂìàÂìàÂìàÂìàÂìà„ÄÇ
        </p>
      </div>
    </div>
  </div>

  <!-- Mobile Controls (touch) -->
  <div id="mobileControls" class="mctl" aria-label="mobile controls">
    <button class="mbtn" data-act="left">‚¨Ö</button>
    <button class="mbtn" data-act="right">‚û°</button>
    <button class="mbtn" data-act="rotate">üîÑ</button>
    <button class="mbtn" data-act="down">‚¨á</button>
    <button class="mbtn wide" data-act="drop">DROP</button>
    <button class="mbtn" data-act="pause">‚è∏</button>
  </div>
  <!-- Mercy modal -->
<div id="mercyModal" class="modal" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="mercyTitle">
      <div class="modal-title" id="mercyTitle">Ê±ÇÈ•∂Ê®°Âºè ü•∫</div>
  
      <div class="modal-desc">
        ËØ∑ËæìÂÖ•ÊöóÂè∑ÂºÄÂêØÊÖ¢ÈÄüÊ®°ÂºèÔºàÊèêÁ§∫ÔºöÊàëÊòØËèúÈ∏°Ôºâ
      </div>
  
      <input
        id="mercyInput"
        class="modal-input"
        type="text"
        inputmode="text"
        autocomplete="on"
        placeholder="‰æãÂ¶ÇÔºöÊàëÊòØËèúÈ∏°"
        list="mercyHints"
      />
      <datalist id="mercyHints">
        <option value="ÊàëÊòØËèúÈ∏°"></option>
        <option value="ÊàëÊòØÊñ∞Êâã"></option>
        <option value="Âà´ÊâìÊàë"></option>
      </datalist>
  
      <div id="mercyTip" class="modal-tip">ËæìÂÖ•Ê≠£Á°ÆÊöóÂè∑Âêé‰ºöÁ´ãÂàªÂáèÈÄü„ÄÇ</div>
  
      <div class="modal-actions">
        <button id="mercyCancel" class="modal-btn ghost">ÂèñÊ∂à</button>
        <button id="mercyOk" class="modal-btn">Á°ÆËÆ§</button>
      </div>
    </div>
  </div>
  <div id="toast" class="toast"></div>
  <!-- Stage clear modal -->
<div id="stageModal" class="modal" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="stageTitle">
      <div class="modal-title" id="stageTitle">ÈÄöÂÖ≥ ‚úÖ</div>
      <div id="stageDesc" class="modal-desc">‰Ω†Â∑≤ÈÄöËøáÊú¨ÂÖ≥ÔºÅ</div>
      <div class="modal-actions">
        <button id="stageNext" class="modal-btn">ËøõÂÖ•‰∏ã‰∏ÄÂÖ≥ ‚ñ∂</button>
      </div>
    </div>
  </div>
  <!-- Endless modal -->
<div id="endlessModal" class="modal" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="endlessTitle">
      <div class="modal-title" id="endlessTitle">ÊèêÁ§∫ üòà</div>
      <div id="endlessDesc" class="modal-desc">ÂÜçÁé©Â∞±Êõ¥Ëèú‰∫Ü</div>
      <div class="modal-actions">
        <button id="endlessContinue" class="modal-btn ghost">ÁªßÁª≠Áé©</button>
        <button id="endlessToPro" class="modal-btn">ÊåëÊàòÂ§ßÁ•ûÊ®°Âºè ‚ö°</button>
      </div>
    </div>
  </div>
<!-- Game Summary modal -->
<div id="summaryModal" class="modal" aria-hidden="true">
  <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="summaryTitle">
    <div class="modal-title" id="summaryTitle">Êú¨Â±ÄÊÄªÁªì üìä</div>
    <div id="summaryBody" class="modal-desc" style="margin-bottom:12px"></div>
    <div class="modal-actions">
      <button id="summaryClose" class="modal-btn ghost">ÂÖ≥Èó≠</button>
      <button id="summaryContinue" class="modal-btn ghost">ÁªßÁª≠Ê∏∏Êàè ‚ñ∂</button>
      <button id="summaryRestart" class="modal-btn">ÂÜçÊù•‰∏ÄÂ±Ä ‚ñ∂</button>
    </div>
  </div>
</div>
<!-- History modal -->
<div id="historyModal" class="modal" aria-hidden="true">
  <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="historyTitle">
    <div class="modal-title" id="historyTitle">ÂéÜÂè≤ËÆ∞ÂΩï üóÇÔ∏è</div>
    <div class="modal-desc" style="margin-bottom:12px">ÊØè‰∏ÄÊääÈÉΩ‰ºöËá™Âä®‰øùÂ≠òÂà∞Êú¨Âú∞ÔºàlocalStorageÔºâ„ÄÇÊåâÊó∂Èó¥ÊéíÂ∫èÔºåÁÇπ‰∏ÄÊù°ÂèØ‰ª•Êü•ÁúãËØ¶ÊÉÖ„ÄÇ</div>

    <div class="his-wrap">
      <div>
        <div class="his-top">
          <div id="historyCount" class="his-count">0 Êù°</div>
          <button id="historyClear" class="modal-btn ghost">Ê∏ÖÁ©∫</button>
        </div>
        <div id="historyList" class="his-list" aria-label="history list"></div>
      </div>

      <div>
        <div class="his-detail" aria-label="history detail">
          <div id="historyDetail" class="modal-desc" style="margin:0">ÁÇπÂ∑¶Ëæπ‰∏ÄÊù°ËÆ∞ÂΩïÊü•Áúã„ÄÇ</div>
        </div>
      </div>
    </div>

    <div class="his-actions" style="margin-top:12px">
      <button id="historyClose" class="modal-btn ghost">ÂÖ≥Èó≠</button>
    </div>
  </div>
</div>
<!-- Clear History Confirm modal -->
<div id="clearHistoryModal" class="modal" aria-hidden="true">
  <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="clearHistoryTitle">
    <div class="modal-title" id="clearHistoryTitle">ÊèêÁ§∫ üòà</div>
    <div class="modal-desc" id="clearHistoryDesc">‰Ω†ÊòØ‰∏çÊòØÁé©‰∏çËµ∑</div>

    <div class="modal-actions">
      <button id="clearHistoryCancel" class="modal-btn ghost">ÊàëÁÇπÈîô‰∫Ü</button>
      <button id="clearHistoryOk" class="modal-btn">ÊòØÁöÑ</button>
    </div>
  </div>
</div>
<!-- Mode Resume modal -->
<div id="modeResumeModal" class="modal" aria-hidden="true">
  <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="modeResumeTitle">
    <div class="modal-title" id="modeResumeTitle">Ê®°ÂºèËøõÂ∫¶</div>
    <div id="modeResumeBody" class="modal-desc" style="margin-bottom:12px"></div>

    <div class="modal-actions">
      <button id="modeResumeCancel" class="modal-btn ghost">ÂèñÊ∂à</button>
      <button id="modeResumeRestart" class="modal-btn ghost">‰ªéÁ¨¨ 1 ÂÖ≥ÈáçÊñ∞ÂºÄÂßã</button>
      <button id="modeResumeContinue" class="modal-btn">ÁªßÁª≠ÂΩìÂâçÁ≠âÁ∫ß ‚ñ∂</button>
    </div>
  </div>
</div>
<div id="modeResumeModal" class="modal">...</div>

<!-- ‚úÖ Âú®ËøôÈáåÂä† -->
<div id="pauseModal" class="modal" aria-hidden="true">
  <div class="modal-card pause-card">
    <h2 class="pause-title">Ê∏∏ÊàèÊöÇÂÅú</h2>

    <button id="pauseContinue" class="btn primary">ÁªßÁª≠Ê∏∏Êàè ‚ñ∂</button>
    <button id="pauseRestart" class="btn">ÈáçÊñ∞ÂºÄÂßã ‚Üª</button>
    <button id="pauseHome" class="btn ghost">ÂõûÂà∞‰∏ªÈ°µÈù¢ üè†</button>
    <button id="pauseSettings" class="btn ghost">ËÆæÁΩÆ / ÊéßÂà∂ üéõ</button>
  </div>
</div>
<script>
(() => {
    // ===== Splash control =====
    const splashEl = document.getElementById('splash');
  const splashStart = Date.now();
  function hideSplash(){
    if(!splashEl) return;
    const wait = Math.max(0, 800 - (Date.now() - splashStart));
    setTimeout(() => {
      splashEl.classList.add('hide');
      setTimeout(() => splashEl.remove(), 320);
    }, wait);
  }
  const W = 10, H = 20;

  // null empty, or "I"/"O"/"T"/"S"/"Z"/"J"/"L" for filled cells
let board = Array.from({length:H}, () => Array(W).fill(null));
  const gridEl = document.getElementById('grid');
  const overlayEl = document.getElementById('overlay');
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const linesEl = document.getElementById('lines');
  const stageEl = document.getElementById('stage');
  const hudScoreEl = document.getElementById('hudScore');
const hudLevelEl = document.getElementById('hudLevel');
const hudLinesEl = document.getElementById('hudLines');
const hudStageEl = document.getElementById('hudStage');
  const btnPro = document.getElementById('btnPro');
  const btnNoob = document.getElementById('btnNoob');
  const btnEndless = document.getElementById('btnEndless');
  const btnNormal = document.getElementById('btnNormal');
  const btnReset = document.getElementById('btnReset');
  if(btnReset) btnReset.classList.add('danger');

const endlessModal = document.getElementById('endlessModal');
const endlessDesc = document.getElementById('endlessDesc');
const endlessContinue = document.getElementById('endlessContinue');
const endlessToPro = document.getElementById('endlessToPro');
const summaryModal = document.getElementById('summaryModal');
const summaryBody  = document.getElementById('summaryBody');
const summaryClose = document.getElementById('summaryClose');
const summaryContinue = document.getElementById('summaryContinue');
const summaryRestart = document.getElementById('summaryRestart');
const pauseModal = document.getElementById('pauseModal');
const pauseContinue = document.getElementById('pauseContinue');
const pauseRestart = document.getElementById('pauseRestart');
const pauseSettings = document.getElementById('pauseSettings');
const pauseHome = document.getElementById('pauseHome');
const pauseCorner = document.getElementById('pauseCorner');
function showPauseButton(){
  pauseCorner?.classList.remove('hidden');
}

function hidePauseButton(){
  pauseCorner?.classList.add('hidden');
}
hidePauseButton();

  // ===== Return to "Home" (start screen) =====
  function goHomeScreen(){
    // close pause modal if open
    try{ closePauseModal?.(); }catch(e){}

    // stop gameplay state
    paused = false;
    gameOver = false;
    stageCleared = false;
    clearingAll = false;
    clearing = false;
    clearingRows = new Set();
    clearingCount = 0;

    // reset score/level/stage HUD to initial look
    score = 0;
    lines = 0;
    level = 1;
    stage = 1;
    stageTarget = stageTargetFor ? stageTargetFor(stage) : 500;

    // reset per-run stats
    piecesLocked = 0;
    hardDrops = 0;
    softDrops = 0;
    gameStartAt = 0;
    summaryShown = false;
    gameOverPendingSave = false;
    savedThisGame = false;
    lockScoreHistory = [];

    // clear special-preview/slowmo state
    nextReveal = false;
    nextWaitingPiece = null;
    slowMoUntil = 0;
    slowMoFactor = 1;
    energyClearActive = false;

    // clear board + piece/bag so the grid renders empty
    board = Array.from({length:H}, () => Array(W).fill(null));
    bag = [];
    nextKind = null;
    piece = null;

    // hide overlays/modals text
    overlayEl?.classList.remove('show');
    if(overlayEl) overlayEl.textContent = "";

    // show start screen, hide pause corner
    started = false;
    startScreen?.classList.add('show');
    hidePauseButton();

    // refresh HUD + redraw empty grid
    try{ updateHUD?.(); }catch(e){}
    try{ draw?.(); }catch(e){}

    // keep start screen mode label synced
    try{ updateStartModeLabel?.(); }catch(e){}
  }
  const stageModal = document.getElementById('stageModal');
  const stageDesc = document.getElementById('stageDesc');
  const stageNext = document.getElementById('stageNext');
  document.getElementById('btnPause').onclick = () => togglePause();
  document.getElementById('btnReset').onclick = () => {
  if(!started) startGame();
  else {
    // ‚úÖ ÂÖàÊääËøô‰∏ÄÊääÂ≠òËµ∑Êù•ÔºàÂè™‰ºöÂ≠ò‰∏ÄÊ¨°Ôºâ
    if(!gameOver) saveRunOnce();
    reset();
  }
};

  // build cells once
  const cells = [];
  for(let i=0;i<W*H;i++){
    const d = document.createElement('div');
    d.className = 'cell';
    gridEl.appendChild(d);
    cells.push(d);
  }

  const SHAPES = {
    I: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
    O: [[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],
    T: [[0,1,0,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],
    S: [[0,1,1,0],[1,1,0,0],[0,0,0,0],[0,0,0,0]],
    Z: [[1,1,0,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],
    J: [[1,0,0,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],
    L: [[0,0,1,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],
    G: [[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],
    E: [[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],
    M: [[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],
    B: [[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],
    C: [[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],

    // 1√ó1 text blocks: Â§©Êô¥Â∞èÂÆùË¥ù
    A: [[0,0,0,0],[0,1,0,0],[0,0,0,0],[0,0,0,0]], // Â§©
    Q: [[0,0,0,0],[0,1,0,0],[0,0,0,0],[0,0,0,0]], // Êô¥
    X: [[0,0,0,0],[0,1,0,0],[0,0,0,0],[0,0,0,0]], // Â∞è
    P: [[0,0,0,0],[0,1,0,0],[0,0,0,0],[0,0,0,0]], // ÂÆù
    K: [[0,0,0,0],[0,1,0,0],[0,0,0,0],[0,0,0,0]], // Ë¥ù
  };
  const ORDER = ["I","O","T","S","Z","J","L","G","E","M","B","C","A","Q","X","P","K"];

  const rotCW = m => m[0].map((_,i) => m.map(r=>r[i]).reverse());
  const cellsOf = m => {
    const out = [];
    for(let y=0;y<4;y++) for(let x=0;x<4;x++) if(m[y][x]) out.push([y,x]);
    return out;
  };
  const rotations = {};
  for(const k of ORDER){
    let m = SHAPES[k];
    const rots = [];
    const seen = new Set();
    for(let i=0;i<4;i++){
      const c = JSON.stringify(cellsOf(m));
      if(!seen.has(c)){ seen.add(c); rots.push(cellsOf(m)); }
      m = rotCW(m);
    }
    rotations[k] = rots;
  }

  // 7-bag random
  let bag = [];
  const refillBag = () => {
    let pool;

    if(endlessMode){
      // Êó†Â∞ΩÔºö‰∏ªË¶Å IÔºàÈïøÊù°Ôºâ‰∏∫‰∏ªÔºåO Ê¨°‰πãÔºõÊûÅ‰ΩéÊ¶ÇÁéáÂ§πÂ∏¶ 1 ‰∏™ÁâπÊÆäÂùóÔºà‰øùÊåÅ‚ÄúÂÅ∂Â∞îÊúâÊÉäÂñú‚ÄùÔºâ
      pool = [
        'I','I','I','I','I','I',
        'O','O','O','O',
        // specials (same low weight style)
        'E','A','Q','X','P','K'
      ];
    }else{
      // ÊôÆÈÄö/Ê±ÇÈ•∂/Â§ßÁ•û/ËèúÈ∏°ÔºöÂ∏∏ËßÑ 7 ÁßçÂΩ¢Áä∂Âç†Â§ßÂ§¥ÔºåÁâπÊÆäÂùóÂæàÂ∞ëÂá∫Áé∞
      const BASE = ['I','O','T','S','Z','J','L'];

      // ËÆ©‚ÄúÈùûÊ≠£ÊñπÂΩ¢‚ÄùÊõ¥Â∏∏ËßÅÔºöI/T/S/Z/J/L ÊùÉÈáçÊõ¥È´òÔºõO Âè™Êîæ 1 Ê¨°
      pool = [
        // I/T/S/Z/J/L ÂêÑ 3 Ê¨°
        'I','I','I',
        'T','T','T',
        'S','S','S',
        'Z','Z','Z',
        'J','J','J',
        'L','L','L',
        // OÔºàÊ≠£ÊñπÂΩ¢ÔºâÂè™ 1 Ê¨°
        'O',

        // ÁâπÊÆäÂùóÔºö‰ΩéÊùÉÈáçÔºàÊØèË¢ãÂêÑ 1 Ê¨°Ôºâ
        'G','E','M','B','C',
        // 1√ó1 Â≠óÂùóÔºöÂ§©Êô¥Â∞èÂÆùË¥ùÔºàÂêÑ 1 Ê¨°Ôºâ
        'A','Q','X','P','K'
      ];
    }
    // Fisher‚ÄìYates shuffle
    for (let i = pool.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [pool[i], pool[j]] = [pool[j], pool[i]];
    }
    bag = pool;
  };

let piece, nextKind;

// ===== In-board next piece preview (appears when current drops to row 4) =====
let nextReveal = false;      // ÊòØÂê¶Â∑≤ÁªèÊää‚Äú‰∏ã‰∏ÄÂùó‚ÄùÊºèÂà∞È°∂ÈÉ®ÊòæÁ§∫
let nextWaitingPiece = null; // { kind, r, x, y } ‰ªÖÁî®‰∫éÊòæÁ§∫Ôºå‰∏çÂèÇ‰∏éÁ¢∞Êíû

let score=0, lines=0, level=1;
  let paused=false, gameOver=false;
  // ===== Combo / Back-to-Back / Perfect Clear =====
  let combo = 0;            // consecutive line-clears
  let b2bEligible = false;  // last clear was a Tetris
  let b2bStreak = 0;        // consecutive Tetris count;
  let gameOverPendingSave = false; // GAME OVER ÂºπÊÄªÁªìÔºå‰ΩÜËøòÊ≤°ÂÜôÂéÜÂè≤ÔºàÁªô‚ÄúÁªßÁª≠Ê∏∏Êàè‚ÄùÁïôÊú∫‰ºöÔºâ
  // ===== Stats for summary =====
  let scoreBeforeGameOver = 0; // ËÆ∞ÂΩïËß¶Âèë GAME OVER ÈÇ£‰∏ÄÂàªÁöÑÂàÜÊï∞ÔºàÁªô‚ÄúÁªßÁª≠Ê∏∏Êàè‚ÄùÁî®Ôºâ
  let lockScoreHistory = []; // ËÆ∞ÂΩïÊØèÊ¨°‚ÄúÈîÅÂùóÂâç‚ÄùÁöÑÂàÜÊï∞ÔºåÁî®‰∫éÁªßÁª≠Ê∏∏ÊàèÂõûÈÄÄÂà∞ 8 Ê¨°Êìç‰ΩúÂâç
  let summaryShown = false; // ÊòØÂê¶Â∑≤ÁªèÂºπËøáÊú¨Â±ÄÊÄªÁªì
let piecesLocked = 0;
let hardDrops = 0;
let softDrops = 0;
let gameStartAt = 0;
  let stage = 1;
let stageTarget = 500;
let proMode = false;        // Â§ßÁ•ûÊ®°ÂºèÔºöÁî®‰Ω†ÂéüÊù•ÁöÑ level ÈÄüÂ∫¶Êú∫Âà∂
let stageCleared = false;   // ÈÄöÂÖ≥ÂêéÁ≠âÂæÖËøõ‰∏ã‰∏ÄÂÖ≥
let clearingAll = false;    // ÈÄöÂÖ≥Êó∂ÂÖ®Âú∫ÊëßÊØÅÂä®Áîª
let noobMode = false; // ËèúÈ∏°Ê®°ÂºèÔºöÊ∂àË°åÂêéÊÇ¨Á©∫ÊñπÂùóËá™Âä®ËêΩ‰∏ã
let endlessMode = false;   // Êó†Â∞ΩÊ®°ÂºèÔºöÂè™Âá∫ O/I
let endlessLocked = false; // Âà∞ 2000 ÂàÜÂêéÂè™Âºπ‰∏ÄÊ¨°
  let mercyOn = false;
let mercyMultiplier = 1; // 1=Ê≠£Â∏∏Ôºå>1 Ë∂äÂ§ßË∂äÊÖ¢
let clearing = false;
let clearingRows = new Set(); // ËÆ∞ÂΩïÊ≠£Âú®Ê∂àÈô§ÁöÑË°å
let clearingCount = 0; // Êú¨Ê¨°Ê∂à‰∫ÜÂá†Ë°åÔºà1-4ÔºâÔºåÁî®‰∫éÊ∏ÖË°åÈó™ÂÖâÂº∫Â∫¶
// ===== Energy slow-mo =====
let slowMoUntil = 0;
let slowMoFactor = 1;
let energyClearActive = false;
// ===== 1√ó1 phrase rule: Â§©Êô¥Â∞èÂÆùË¥ù => clear ALL (with animation) =====
let phraseClearActive = false;
const PHRASE_SEQ = ['A','Q','X','P','K']; // Â§© Êô¥ Â∞è ÂÆù Ë¥ù
const PHRASE_STAGGER_MS = 18;            // left‚Üíright, top‚Üíbottom wave

function findPhraseInRows(){
  for(let y=0; y<H; y++){
    for(let x=0; x<=W-5; x++){
      let ok = true;
      for(let i=0;i<5;i++){
        if(board[y][x+i] !== PHRASE_SEQ[i]){ ok = false; break; }
      }
      if(ok) return { y, x };
    }
  }
  return null;
}

function triggerPhraseClearAll(){
  if(phraseClearActive) return false;
  const hit = findPhraseInRows();
  if(!hit) return false;

  phraseClearActive = true;

  // freeze gameplay during animation
  paused = true;
  try{ closePauseModal?.(); }catch(e){}
  overlayEl?.classList.remove('show');
  if(overlayEl) overlayEl.textContent = "";

  // ensure current board is rendered before shattering
  try{ draw?.(); }catch(e){}
  const boardEl = document.querySelector('.board');
boardEl?.classList.remove('phrase-pop');
void boardEl?.offsetWidth;
boardEl?.classList.add('phrase-pop');
  let lastDelay = 0;

  // animate filled cells in a wave: left‚Üíright, top‚Üíbottom
  for(let y=0; y<H; y++){
    for(let x=0; x<W; x++){
      const k = board[y][x];
      if(!k) continue;

      const idx = y*W + x;
      const d = (y*W + x) * PHRASE_STAGGER_MS;
      lastDelay = Math.max(lastDelay, d);

      const el = cells[idx];
      if(!el) continue;

      // use existing shatter animation (.cell.clearing)
      el.style.setProperty('--ad', d + 'ms');
      el.classList.add('phrase-clearing','clear-4');
    }
  }

  // after the wave finishes, truly clear the board and continue
  const SAFE_END_MS = 140; // a bit larger than --clear-dur (.28s)
  setTimeout(() => {
    // clear board data
    board = Array.from({length:H}, () => Array(W).fill(null));

    // clean DOM animation classes
    for(let i=0;i<cells.length;i++){
      const el = cells[i];
      el.classList.remove('phrase-clearing','clearing','clear-1','clear-2','clear-3','clear-4');
      el.style.removeProperty('--ad');
    }

    // reset related state
    clearing = false;
    clearingRows = new Set();
    clearingCount = 0;

    nextReveal = false;
    nextWaitingPiece = null;

    phraseClearActive = false;
    paused = false;

    // continue game
    spawn();
    draw();
  }, lastDelay + SAFE_END_MS);

  return true;
}
// ===== Step 9: ‰∏ªÈ¢òËâ≤ + ÂΩìÂâçÊ®°ÂºèÊåâÈíÆÈ´ò‰∫Æ =====
function setAccent(rgb){
  document.documentElement.style.setProperty('--accent-rgb', rgb);
}

function setActiveModeButton(key){
  const map = {
    normal: btnNormal,
    mercy: btnMercy,
    pro: btnPro,
    noob: btnNoob,
    endless: btnEndless
  };

  Object.values(map).forEach(b => b && b.classList.remove('active'));
  if(map[key]) map[key].classList.add('active');
}

function applyThemeByMode(){
  if(mercyOn){
    setAccent('34,197,94');     // Áªø
    setActiveModeButton('mercy');
    return;
  }
  if(proMode){
    setAccent('168,85,247');    // Á¥´
    setActiveModeButton('pro');
    return;
  }
  if(noobMode){
    setAccent('34,197,94');     // Áªø
    setActiveModeButton('noob');
    return;
  }
  if(endlessMode){
    setAccent('239,68,68');     // Á∫¢
    setActiveModeButton('endless');
    return;
  }

  // ÊôÆÈÄöÊ®°Âºè
  setAccent('34,211,238');      // Èùí
  setActiveModeButton('normal');
}
  // ===== Toast helper =====
  const toastEl = document.getElementById('toast');
  function showToast(msg, tone){
    if(!toastEl) return;
    toastEl.textContent = msg;

    // reset tone classes
    toastEl.classList.remove('combo','b2b','pc','tetris');
    if(tone) toastEl.classList.add(tone);

    toastEl.classList.remove('show');
    // Âº∫Âà∂ÈáçÂêØÂä®Áîª
    void toastEl.offsetWidth;
    toastEl.classList.add('show');
  }
  const lineScore = {1:100,2:300,3:500,4:800};
  function openStageModal(){
  if(!stageModal) return;
  stageModal.classList.add('show');
  stageModal.setAttribute('aria-hidden','false');
}
function closeStageModal(){
  if(!stageModal) return;
  stageModal.classList.remove('show');
  stageModal.setAttribute('aria-hidden','true');
}

function winStage(){
  if(stageCleared || proMode) return;
  stageCleared = true;
  clearingAll = true;

  draw(); // ËÆ©ÂÖ®Âú∫ÊñπÂùóÂºÄÂßãÊí≠Êîæ clearing Âä®Áîª

  setTimeout(() => {
    board = Array.from({length:H}, () => Array(W).fill(null));
    clearingAll = false;

    paused = true;
    overlayEl.textContent = "STAGE CLEAR";
    overlayEl.classList.add('show');

    stageTarget = stageTargetFor(stage);
    if(stageDesc) stageDesc.textContent = `Á¨¨ ${stage} ÂÖ≥ÈÄöÂÖ≥ÔºÅÁõÆÊ†á ${stageTarget} ÂàÜÂ∑≤ËææÊàê„ÄÇÁÇπÂáªËøõÂÖ•‰∏ã‰∏ÄÂÖ≥„ÄÇ`;
    saveRunOnce(); // ‚úÖ CÔºöÈÄöÂÖ≥‰πüÂ≠ò‰∏ÄÊää
    openStageModal();
    draw();
  }, 280);
}

function checkStage(){
  if(proMode) return;
  if(stageCleared) return;
  if(endlessMode) return;
  stageTarget = stageTargetFor(stage);
  if(score >= stageTarget){
    winStage();
  }
}
function openEndlessModal(){
  if(!endlessModal) return;
  endlessModal.classList.add('show');
  endlessModal.setAttribute('aria-hidden','false');
}
function closeEndlessModal(){
  if(!endlessModal) return;
  endlessModal.classList.remove('show');
  endlessModal.setAttribute('aria-hidden','true');
}
function openSummaryModal(){
  if(!summaryModal) return;
  renderSummary();
  summaryModal.classList.add('show');
  summaryModal.setAttribute('aria-hidden','false');
}
function closeSummaryModal(){
  if(!summaryModal) return;
  summaryModal.classList.remove('show');
  summaryModal.setAttribute('aria-hidden','true');
}
function openPauseModal(){
  if(!pauseModal) return;
  paused = true;
  overlayEl?.classList.add('show');
  pauseModal.classList.add('show');
  pauseModal.setAttribute('aria-hidden','false');
}

function closePauseModal(){
  if(!pauseModal) return;
  pauseModal.classList.remove('show');
  pauseModal.setAttribute('aria-hidden','true');
}
function continueAfterGameOver(){
  summaryShown = false;
  if(!gameOver) return;

  // ÁªßÁª≠Ôºö‰∏çÈáçÂºÄÔºå‰∏çÊ∏ÖÂàÜÊï∞/ÂÖ≥Âç°/Á≠âÁ∫ß
  gameOver = false;
  gameOverPendingSave = false;
  savedThisGame = false; // ÂÖÅËÆ∏ÂêéÈù¢Ê≠£Â∏∏Â≠ò‰∏ÄÊ¨°

  paused = false;
  stageCleared = false;
  clearingAll = false;
  clearing = false;
  clearingRows = new Set();

  overlayEl.classList.remove('show');
  overlayEl.textContent = "";

  closeSummaryModal();

  // ‰∏∫‰∫ÜËÉΩÁªßÁª≠ÔºöÊ∏ÖÊéâÈ°∂ÈÉ® 8 Ë°åÔºåÁ≠â‰∫é‚ÄúÊí§ÂõûÊúÄÂêé 8 ‰∏™Êìç‰Ωú‚ÄùÔºå‰øùËØÅËÉΩÁîüÊàêÊñ∞ÊñπÂùó
for(let y=0; y<8; y++){
  for(let x=0; x<W; x++) board[y][x] = null;
}
// ‚úÖ ÁªßÁª≠Ê∏∏ÊàèÔºöÂõûÂà∞‚ÄúÊí§ÂõûÊúÄÂêé 8 Ê¨°ÈîÅÂùó‰πãÂâç‚ÄùÁöÑÂàÜÊï∞ÔºàÂè™ÂõûÈÄÄÂàÜÊï∞ÔºåÂÖ∂‰ªñ‰∏çÂèòÔºâ
const idx = Math.max(0, lockScoreHistory.length - 8);
score = lockScoreHistory.length ? lockScoreHistory[idx] : baseScoreForStage(stage);
updateHUD();
nextReveal = false;
nextWaitingPiece = null;
  // Â∞ùËØïÁîüÊàêÔºõÂ¶ÇÊûúËøòÊîæ‰∏ç‰∏ãÂ∞±Áõ¥Êé•Ê∏ÖÁ©∫Ê£ãÁõòÁªßÁª≠
  spawn();
  if(gameOver){
    gameOver = false;
    board = Array.from({length:H}, () => Array(W).fill(null));
    bag = [];
    nextKind = null;
    spawn();
  }

  draw();
}

function fmtTime(ms){
  const s = Math.max(0, Math.floor(ms/1000));
  const mm = String(Math.floor(s/60)).padStart(2,'0');
  const ss = String(s%60).padStart(2,'0');
  return `${mm}:${ss}`;
}

function modeLabel(){
  const m = [];
  if(proMode) m.push('Â§ßÁ•û');
  if(noobMode) m.push('ËèúÈ∏°');
  if(endlessMode) m.push('Êó†Â∞Ω');
  if(mercyOn) m.push('Ê±ÇÈ•∂');
  return m.length ? m.join(' / ') : 'ÊôÆÈÄö';
}
// ===== Per-mode progress (localStorage) =====
const MODE_SAVE_KEY = 'tetris_mode_progress_v1';

function modeKeyFromFlags(){
  if(proMode) return 'pro';
  if(noobMode) return 'noob';
  if(endlessMode) return 'endless';
  if(mercyOn) return 'mercy';
  return 'normal';
}

function modeLabelFromKey(k){
  if(k === 'pro') return 'Â§ßÁ•û';
  if(k === 'noob') return 'ËèúÈ∏°';
  if(k === 'endless') return 'Êó†Â∞Ω';
  if(k === 'mercy') return 'Ê±ÇÈ•∂';
  return 'ÊôÆÈÄö';
}

function loadModeProgressAll(){
  try{
    const raw = localStorage.getItem(MODE_SAVE_KEY);
    const obj = raw ? JSON.parse(raw) : {};
    return (obj && typeof obj === 'object') ? obj : {};
  }catch(e){
    return {};
  }
}

function saveModeProgressAll(all){
  try{ localStorage.setItem(MODE_SAVE_KEY, JSON.stringify(all)); }catch(e){}
}

function saveCurrentModeProgress(){
  const key = modeKeyFromFlags();
  const all = loadModeProgressAll();

  const cur = {
    stage: stage ?? 1,
    level: level ?? 1,
    score: score ?? 0,
    lines: lines ?? 0,
    ts: Date.now(),
  };

  const prev = all[key];
  if(!prev){
    all[key] = cur;
    saveModeProgressAll(all);
    return;
  }

  const prevStage = prev.stage ?? 1;
  const prevLevel = prev.level ?? 1;
  const prevScore = prev.score ?? 0;
  const prevLines = prev.lines ?? 0;

  // ËßÑÂàôÔºö
  // 1) ÂÖ≥Âç°Êõ¥È´ò -> Áõ¥Êé•Áî®ÂΩìÂâçËÆ∞ÂΩï
  // 2) ÂêåÂÖ≥Âç°‰ΩÜÁ≠âÁ∫ßÊõ¥È´ò -> Áõ¥Êé•Áî®ÂΩìÂâçËÆ∞ÂΩï
  // 3) ÂêåÂÖ≥ÂêåÁ∫ß -> ÂàÜÊï∞/Ê∂àË°åÂèñÊõ¥È´òÔºà‰øùÊåÅÊúÄÈ´òËÆ∞ÂΩïÔºâ
  if(cur.stage > prevStage || (cur.stage === prevStage && cur.level > prevLevel)){
    all[key] = cur;
  }else if(cur.stage === prevStage && cur.level === prevLevel){
    all[key] = {
      stage: prevStage,
      level: prevLevel,
      score: Math.max(prevScore, cur.score),
      lines: Math.max(prevLines, cur.lines),
      ts: Date.now(),
    };
  } // ÂÖ≥Âç°/Á≠âÁ∫ßÊõ¥‰ΩéÔºöÂøΩÁï•Ôºå‰∏çË¶ÜÁõñÊúÄÈ´òËÆ∞ÂΩï

  saveModeProgressAll(all);
}

function fmtDateShort(ts){
  try{ return new Date(ts).toLocaleString('zh-CN', { hour12:false }); }
  catch(e){ return ''; }
}

// Âè™ÈáçÁΩÆÊ£ãÁõò/Ë¢ãÂ≠ê/ÂΩìÂâçÂùóÔºå‰∏çÂä® stage/level/score/lines
function resetBoardOnly(){
  board = Array.from({length:H}, () => Array(W).fill(null));

  piecesLocked = 0;
  hardDrops = 0;
  softDrops = 0;
  gameStartAt = Date.now();
  savedThisGame = false;
  resetModeTrail();

  paused = false;
  gameOver = false;
  stageCleared = false;
  clearingAll = false;
  clearing = false;
  clearingRows = new Set();

  closeSummaryModal();
  closeStageModal();
  closeEndlessModal?.();

  overlayEl.classList.remove('show');
  overlayEl.textContent = "PAUSED";

  bag = [];
  nextKind = null;
  updateHUD();
  spawn();
  draw();
}

// ===== Mode resume modal elements =====
const modeResumeModal = document.getElementById('modeResumeModal');
const modeResumeTitle = document.getElementById('modeResumeTitle');
const modeResumeBody  = document.getElementById('modeResumeBody');
const modeResumeCancel = document.getElementById('modeResumeCancel');
const modeResumeRestart = document.getElementById('modeResumeRestart');
const modeResumeContinue = document.getElementById('modeResumeContinue');

let pendingModeKey = null;
let pendingModeAction = null; // 'restart' | 'continue'
let pendingModeSave = null;

function openModeResumeModal(){
  if(!modeResumeModal) return;
  modeResumeModal.classList.add('show');
  modeResumeModal.setAttribute('aria-hidden','false');
}

function closeModeResumeModal(){
  if(!modeResumeModal) return;
  modeResumeModal.classList.remove('show');
  modeResumeModal.setAttribute('aria-hidden','true');
}

function setFlagsByModeKey(k){
  // ÂÖàÂÖ≥ÊâÄÊúâÊ®°ÂºèÔºàÂåÖÊã¨Ê±ÇÈ•∂Ôºâ
  turnOffAllModes();

  if(k === 'pro'){
    proMode = true;
    if(btnPro) btnPro.textContent = 'Â§ßÁ•ûÊ®°Âºè ‚úÖÔºàÊÖ¢ÊÖ¢ÂèòÂø´Ôºâ';
  }else if(k === 'noob'){
    noobMode = true;
    if(btnNoob) btnNoob.textContent = 'ËèúÈ∏°Ê®°Âºè ‚úÖÔºàÊÇ¨Á©∫Ëá™Âä®ËêΩÔºâ';
  }else if(k === 'endless'){
    endlessMode = true;
    endlessLocked = false;
    if(btnEndless) btnEndless.textContent = 'Êó†Â∞ΩÊ®°Âºè ‚úÖÔºàÂè™Âá∫ O/IÔºâ';
  }else if(k === 'normal'){
    // ÊôÆÈÄöÔºöÂÖ®ÈÉ®ÂÖ≥Èó≠Â∞±Ë°å
  }else if(k === 'mercy'){
    // Ê±ÇÈ•∂Ôºö‰∏çÁõ¥Êé•ÂºÄÔºåÁ≠âÁé©ÂÆ∂ËæìÊöóÂè∑ÊàêÂäüÂêé setMercy(true)
  }

  try{ pushModeTrail?.(); }catch(e){}
  applyThemeByMode();
}

function applyModeWithRestart(k){
  setFlagsByModeKey(k);
  started = true;
  startScreen?.classList.remove('show');
  reset();
}

function applyModeWithContinue(k, save){
  setFlagsByModeKey(k);

  if(save){
    stage = save.stage ?? 1;
    level = save.level ?? 1;
    score = save.score ?? 0;
    lines = save.lines ?? 0;
  }

  started = true;
  startScreen?.classList.remove('show');
  resetBoardOnly();
}

function requestModeChange(k){
  // ÂàáÊ®°ÂºèÂâçÔºåÊääÂΩìÂâçËøôÊääÂÖàÂ≠ò‰∏Ä‰∏ãÔºàÈÅøÂÖç‰∏¢ËøõÂ∫¶Ôºâ
  if(started && !gameOver) saveRunOnce();

  const all = loadModeProgressAll();
  const save = all[k];

  // Ê≤°Â≠òÊ°£ÔºöÁõ¥Êé•ÂΩì‚ÄúÈáçÂºÄ‚Äù
  if(!save){
    if(k === 'mercy'){
      pendingModeKey = 'mercy';
      pendingModeAction = 'restart';
      pendingModeSave = null;
      setFlagsByModeKey('mercy');
      openMercy();
      return;
    }
    applyModeWithRestart(k);
    return;
  }

  // ÊúâÂ≠òÊ°£ÔºöÂºπÁ™óËÆ©Áé©ÂÆ∂ÈÄâ
  pendingModeKey = k;
  pendingModeSave = save;

  if(modeResumeTitle) modeResumeTitle.textContent = `${modeLabelFromKey(k)} Ê®°ÂºèËøõÂ∫¶`;
  if(modeResumeBody){
    modeResumeBody.innerHTML = `
      <div class="summary">
      <div class="row"><span>ËÆ∞ÂΩïÊó∂Èó¥</span><b>${save.ts ? fmtDateShort(save.ts) : '-'}</b></div>
<div class="row"><span>ÂéÜÂè≤ÊúÄÈ´òÂÖ≥Âç°</span><b>${save.stage ?? 1}</b></div>
<div class="row"><span>ÂéÜÂè≤ÊúÄÈ´òÁ≠âÁ∫ß</span><b>${save.level ?? 1}</b></div>
<div class="row"><span>ÂéÜÂè≤ÊúÄÈ´òÂàÜ</span><b>${save.score ?? 0}</b></div>
<div class="row"><span>ÂéÜÂè≤ÊúÄÈ´òÊ∂àË°å</span><b>${save.lines ?? 0}</b></div>
<small>‚ÄúÁªßÁª≠‚Äù‰ºö‰ªéËØ•Ê®°Âºè„ÄêÂéÜÂè≤ÊúÄÈ´ò„ÄëËøõÂ∫¶ÁªßÁª≠Ôºõ‚ÄúÈáçÊñ∞ÂºÄÂßã‚Äù‰ªéÁ¨¨ 1 ÂÖ≥ÈáçÊñ∞Êù•„ÄÇ</small>  
      </div>
    `;
  }

  openModeResumeModal();
}
// ===== Mode trail (track mode switches within a run) =====
let modeTrail = [];

function resetModeTrail(){
  // Êú¨Â±ÄËµ∑ÁÇπÔºöÂΩìÂâçÊ®°Âºè
  modeTrail = [modeLabel()];
}

function pushModeTrail(){
  const cur = modeLabel();
  const last = modeTrail.length ? modeTrail[modeTrail.length - 1] : null;
  if(cur && cur !== last) modeTrail.push(cur);
}
// ===== History (localStorage) =====
const btnHistory = document.getElementById('btnHistory'); // Ê≤°ÊúâÊåâÈíÆ‰πü‰∏çÂΩ±ÂìçÔºàÂèØÈÄâÔºâ
const historyModal = document.getElementById('historyModal');
const historyList = document.getElementById('historyList');
const historyDetail = document.getElementById('historyDetail');
const historyClose = document.getElementById('historyClose');
const historyClear = document.getElementById('historyClear');
const historyCount = document.getElementById('historyCount');
const clearHistoryModal = document.getElementById('clearHistoryModal');
const clearHistoryCancel = document.getElementById('clearHistoryCancel');
const clearHistoryOk = document.getElementById('clearHistoryOk');

const LS_KEY = 'tetris_runs_v1';
let savedThisGame = false;
let historyCache = [];

function loadHistory(){
  try{
    const raw = localStorage.getItem(LS_KEY);
    const arr = raw ? JSON.parse(raw) : [];
    historyCache = Array.isArray(arr) ? arr : [];
  }catch(e){
    historyCache = [];
  }
  historyCache.sort((a,b) => (b.ts||0) - (a.ts||0)); // ÊúÄÊñ∞Âú®Ââç
}

function saveHistory(){
  try{ localStorage.setItem(LS_KEY, JSON.stringify(historyCache)); }catch(e){}
}

function fmtDate(ts){
  try{ return new Date(ts).toLocaleString('zh-CN', { hour12:false }); }
  catch(e){ return String(ts); }
}

function snapshotRun(){
  const dur = gameStartAt ? (Date.now() - gameStartAt) : 0;
  return {
    id: String(Date.now()) + '-' + Math.random().toString(16).slice(2),
    ts: Date.now(),
    score, lines, stage, level,
    piecesLocked, hardDrops, softDrops,
    durationMs: dur,
    mode: modeLabel(),
    modeTrail: Array.isArray(modeTrail) ? modeTrail.slice() : [modeLabel()],
  };
}

function saveRunOnce(){
  if(savedThisGame) return;
  if(!Array.isArray(modeTrail) || modeTrail.length === 0) resetModeTrail();
pushModeTrail();
  savedThisGame = true;
  loadHistory();
  historyCache.unshift(snapshotRun());
  if(historyCache.length > 200) historyCache.length = 200;
  saveHistory();
saveCurrentModeProgress();
}

function renderHistoryDetail(run){
  if(!historyDetail) return;
  if(!run){
    historyDetail.innerHTML = 'ÁÇπÂ∑¶Ëæπ‰∏ÄÊù°ËÆ∞ÂΩïÊü•Áúã„ÄÇ';
    return;
  }
  historyDetail.innerHTML = `
    <div class="summary">
      <div class="row"><span>Êó∂Èó¥</span><b>${fmtDate(run.ts)}</b></div>
      <div class="row"><span>ÂæóÂàÜ</span><b>${run.score ?? 0}</b></div>
      <div class="row"><span>Ê∂àË°å</span><b>${run.lines ?? 0}</b></div>
      <div class="row"><span>ÂÖ≥Âç°</span><b>${run.stage ?? 1}</b></div>
      <div class="row"><span>Á≠âÁ∫ß</span><b>${run.level ?? 1}</b></div>
      <div class="row"><span>ËêΩÂùóÊï∞</span><b>${run.piecesLocked ?? 0}</b></div>
      <div class="row"><span>Á°¨ÈôçÊ¨°Êï∞</span><b>${run.hardDrops ?? 0}</b></div>
      <div class="row"><span>ËΩØÈôçÊ¨°Êï∞</span><b>${run.softDrops ?? 0}</b></div>
      <div class="row"><span>Áî®Êó∂</span><b>${fmtTime(run.durationMs ?? 0)}</b></div>
    <div class="row"><span>Ê®°Âºè</span><b>${(Array.isArray(run.modeTrail) && run.modeTrail.length ? run.modeTrail.join(' ‚Üí ') : (run.mode ?? 'ÊôÆÈÄö'))}</b></div>
    </div>
  `;
}

function renderHistoryList(){
  if(!historyList) return;
  if(historyCount) historyCount.textContent = `${historyCache.length} Êù°`;

  if(historyCache.length === 0){
    historyList.innerHTML = `<div class="modal-desc" style="padding:10px 12px; margin:0">ÊöÇÊó†ËÆ∞ÂΩïÔºåÂÖàÁé©‰∏ÄÊää„ÄÇ</div>`;
    renderHistoryDetail(null);
    return;
  }

  historyList.innerHTML = historyCache.map((run) => {
    return `
      <button class="his-item" data-hid="${run.id}">
        <div>
          ${fmtDate(run.ts)}
          <small>Score ${run.score ?? 0} ¬∑ Lines ${run.lines ?? 0} ¬∑ ${run.mode ?? 'ÊôÆÈÄö'}</small>
        </div>
        <div>‚Ä∫</div>
      </button>
    `;
  }).join('');

  renderHistoryDetail(historyCache[0]);

  historyList.querySelectorAll('button[data-hid]').forEach(btn => {
    btn.addEventListener('click', () => {
      const id = btn.getAttribute('data-hid');
      const run = historyCache.find(r => r.id === id);
      renderHistoryDetail(run);
    });
  });
}

function openHistoryModal(){
  if(!historyModal) return;
  loadHistory();
  renderHistoryList();
  historyModal.classList.add('show');
  historyModal.setAttribute('aria-hidden','false');
}

function closeHistoryModal(){
  if(!historyModal) return;
  historyModal.classList.remove('show');
  historyModal.setAttribute('aria-hidden','true');
}
function openClearHistoryModal(){
  if(!clearHistoryModal) return;
  clearHistoryModal.classList.add('show');
  clearHistoryModal.setAttribute('aria-hidden','false');
}
function closeClearHistoryModal(){
  if(!clearHistoryModal) return;
  clearHistoryModal.classList.remove('show');
  clearHistoryModal.setAttribute('aria-hidden','true');
}
function renderSummary(){
  if(!summaryBody) return;
  const dur = gameStartAt ? (Date.now() - gameStartAt) : 0

  summaryBody.innerHTML = `
    <div class="summary">
      <div class="row"><span>ÂæóÂàÜ</span><b>${score}</b></div>
      <div class="row"><span>Ê∂àË°å</span><b>${lines}</b></div>
      <div class="row"><span>ÂÖ≥Âç°</span><b>${stage}</b></div>
      <div class="row"><span>Á≠âÁ∫ß</span><b>${level}</b></div>
      <div class="row"><span>ËêΩÂùóÊï∞</span><b>${piecesLocked}</b></div>
      <div class="row"><span>Á°¨ÈôçÊ¨°Êï∞</span><b>${hardDrops}</b></div>
      <div class="row"><span>ËΩØÈôçÊ¨°Êï∞</span><b>${softDrops}</b></div>
      <div class="row"><span>Áî®Êó∂</span><b>${fmtTime(dur)}</b></div>
      <div class="row"><span>Ê®°Âºè</span><b>${modeLabel()}</b></div>
      <small>ÊèêÁ§∫ÔºöÊÉ≥Êõ¥Âº∫ÔºüËèúÂ∞±Â§öÁªÉ üòà</small>
    </div>
  `;
}

// summary buttons
summaryClose?.addEventListener('click', () => {
  // Â¶ÇÊûúÊòØ GAME OVER Ëß¶ÂèëÁöÑÊÄªÁªìÔºöÊ≠§Êó∂ÊâçÁÆó‰∏ÄÂ±ÄÁªìÊùüÔºåÂÜôÂÖ•ÂéÜÂè≤
  if(gameOverPendingSave){
    saveRunOnce();
    gameOverPendingSave = false;
  }
  closeSummaryModal();
});

summaryContinue?.addEventListener('click', () => {
  // ÁªßÁª≠Ê∏∏ÊàèÔºö‰∏çÂÜôÂéÜÂè≤Ôºå‰∏çÈáçÂºÄ
  continueAfterGameOver();
});

summaryRestart?.addEventListener('click', () => {
  // Â¶ÇÊûúÊòØ GAME OVER Ëß¶ÂèëÁöÑÊÄªÁªìÔºöÊ≠§Êó∂ÊâçÁÆó‰∏ÄÂ±ÄÁªìÊùüÔºåÂÜôÂÖ•ÂéÜÂè≤
  if(gameOverPendingSave){
    saveRunOnce();
    gameOverPendingSave = false;
  }

  closeSummaryModal();
  if(!started){
    startGame();
  } else {
  const keepStage = stage;
  const keepLevel = level;

  reset(); // ‰ºöÊää stage/level/score Ê∏ÖÂõû 1/1/0

  stage = keepStage;
  level = keepLevel;

  score = baseScoreForStage(stage); // ‚úÖ ÂÜçÊù•‰∏ÄÂ±ÄÔºöÂàÜÊï∞ÂõûÂà∞ÂΩìÂâçÂÖ≥Âç°Âü∫Á°ÄÂàÜ
  updateHUD();

  paused = false;
  overlayEl.classList.remove('show');
overlayEl.textContent = "";
}
});

// ÁÇπÂáªÈÅÆÁΩ©ÂÖ≥Èó≠
summaryModal?.addEventListener('click', (e) => {
  if(e.target === summaryModal) closeSummaryModal();
});
btnHistory?.addEventListener('click', () => openHistoryModal());
// ===== Start screen: Mode + History buttons =====
const btnStartMode = document.getElementById('btnStartMode');
const btnStartHistory = document.getElementById('btnStartHistory');
const startModeMenu = document.getElementById('startModeMenu');

function updateStartModeLabel(){
  if(!btnStartMode) return;
  btnStartMode.textContent = `Ê®°ÂºèÔºö${modeLabel()} ‚ñæ`;
}

// ÁÇπÂáª‚ÄúÈÄâÊã©Ê®°Âºè‚Äù -> Â±ïÂºÄ/Êî∂Ëµ∑ËèúÂçï
btnStartMode?.addEventListener('click', () => {
  if(!startModeMenu) return;
  startModeMenu.hidden = !startModeMenu.hidden;
});

// ÁÇπÂáª‚ÄúÂéÜÂè≤ËÆ∞ÂΩï‚Äù -> Áõ¥Êé•ÊâìÂºÄ‰Ω†Áé∞ÊàêÁöÑÂéÜÂè≤ÂºπÁ™ó
btnStartHistory?.addEventListener('click', () => {
  openHistoryModal?.();
});

// ËèúÂçïÈáåÁÇπÊüê‰∏™Ê®°Âºè
startModeMenu?.querySelectorAll('.start-menu-item[data-mode]').forEach((b) => {
  b.addEventListener('click', () => {
    const k = b.getAttribute('data-mode');

    // ‚úÖ ÂÖ≥ÈîÆÔºöÂ¶ÇÊûúËøòÊ≤°ÂºÄÂßãÊ∏∏ÊàèÔºåÂè™‚ÄúÈ¢ÑÈÄâÊ®°Âºè‚ÄùÔºå‰∏çÁõ¥Êé•ÂºÄÂ±Ä
    if(!started){
      if(k === 'mercy'){
        setFlagsByModeKey('mercy');
        openMercy?.();        // ‰Ω†Â∑≤ÊúâÁöÑÊ±ÇÈ•∂ÊöóÂè∑ÂºπÁ™ó
      }else{
        setFlagsByModeKey(k); // Âè™ÊîπÊ®°Âºè flagÔºå‰∏ç reset ‰∏çÂºÄÂ±Ä
      }
      applyThemeByMode?.();
      updateStartModeLabel();
      startModeMenu.hidden = true;
      return;
    }

    // Â¶ÇÊûúÂ∑≤ÁªèÂú®Áé©‰∫ÜÔºåÈÇ£Â∞±Êåâ‰Ω†ÂéüÊù•ÁöÑÈÄªËæëÂàáÊ®°ÂºèÔºà‰ºöÂºπÁªßÁª≠/ÈáçÂºÄÁ≠âÔºâ
    requestModeChange?.(k);
    updateStartModeLabel();
    startModeMenu.hidden = true;
  });
});

// ÂàùÂßãÂà∑Êñ∞‰∏ÄÊ¨°ÊåâÈíÆÊñáÂ≠ó
updateStartModeLabel();
historyClose?.addEventListener('click', () => closeHistoryModal());
historyModal?.addEventListener('click', (e) => {
  if(e.target === historyModal) closeHistoryModal();
});
historyClear?.addEventListener('click', () => {
  openClearHistoryModal();
});
clearHistoryCancel?.addEventListener('click', () => {
  closeClearHistoryModal();
});

clearHistoryOk?.addEventListener('click', () => {
  historyCache = [];
  saveHistory();
  renderHistoryList();
  closeClearHistoryModal();
});

// ÁÇπÈÅÆÁΩ©ÂÖ≥Èó≠
clearHistoryModal?.addEventListener('click', (e) => {
  if(e.target === clearHistoryModal) closeClearHistoryModal();
});
// ===== Mode Resume modal events =====
modeResumeCancel?.addEventListener('click', () => {
  pendingModeKey = null;
  pendingModeSave = null;
  closeModeResumeModal();
});

modeResumeModal?.addEventListener('click', (e) => {
  if(e.target === modeResumeModal){
    pendingModeKey = null;
    pendingModeSave = null;
    closeModeResumeModal();
  }
});

modeResumeRestart?.addEventListener('click', () => {
  const k = pendingModeKey;
  const save = pendingModeSave;
  pendingModeKey = null;
  pendingModeSave = null;
  closeModeResumeModal();

  if(!k) return;

  if(k === 'mercy'){
    pendingModeKey = 'mercy';
    pendingModeAction = 'restart';
    pendingModeSave = save;
    setFlagsByModeKey('mercy');
    openMercy();
    return;
  }

  applyModeWithRestart(k);
});
// ‚è∏ Ê£ãÁõòÂè≥‰∏äËßíÊöÇÂÅúÊåâÈíÆ
pauseCorner?.addEventListener('click', () => {
  if(!started || gameOver) return; // üîí Âè™ÂÖÅËÆ∏Ê∏∏Êàè‰∏≠ÊöÇÂÅú
  if(paused) return;
  openPauseModal();
});

// ‚ñ∂ ÁªßÁª≠Ê∏∏Êàè
pauseContinue?.addEventListener('click', () => {
  closePauseModal();
  paused = false;
  overlayEl?.classList.remove('show');
});

// ‚Üª ÈáçÊñ∞ÂºÄÂßã
pauseRestart?.addEventListener('click', () => {
  closePauseModal();
  paused = false;
  reset();
});

// üè† ÂõûÂà∞‰∏ªÈ°µÈù¢ÔºàÂºÄÂßãÁïåÈù¢Ôºâ
pauseHome?.addEventListener('click', () => {
  goHomeScreen(); // ‚úÖ ÂõûÂà∞‚ÄúÂàöÊâìÂºÄÊ∏∏Êàè‚ÄùÁöÑÂπ≤ÂáÄÁä∂ÊÄÅ
});

// üéõ ËÆæÁΩÆ / ÊéßÂà∂ÔºàÂç†‰ΩçÔºâ
pauseSettings?.addEventListener('click', () => {
  // ÊöÇÊó∂‰∏çÂÜô‰ªª‰ΩïÈÄªËæë
});

modeResumeContinue?.addEventListener('click', () => {
  const k = pendingModeKey;
  const save = pendingModeSave;
  pendingModeKey = null;
  pendingModeSave = null;
  closeModeResumeModal();

  if(!k) return;

  if(k === 'mercy'){
    pendingModeKey = 'mercy';
    pendingModeAction = 'continue';
    pendingModeSave = save;
    setFlagsByModeKey('mercy');
    openMercy();
    return;
  }

  applyModeWithContinue(k, save);
});

function checkEndlessCap(){
  if(!endlessMode) return;
  if(endlessLocked) return;
  if(score >= 1000){
    endlessLocked = true;
    paused = true;
    overlayEl.textContent = "1000+";
    overlayEl.classList.add('show');
    if(endlessDesc) endlessDesc.textContent = "ÂÜçÁé©Â∞±Êõ¥Ëèú‰∫Ü";
    openEndlessModal();
  }
}
  function spawn(){
    if(bag.length === 0) refillBag();
    const kind = nextKind ?? bag.pop();
    if(bag.length === 0) refillBag();
    nextKind = bag.pop();

    nextReveal = false;
nextWaitingPiece = null;

    piece = { kind, r:0, x:3, y:0 };
    if(!canPlace(piece, 0, 0, 0)) {
      gameOver = true;
      scoreBeforeGameOver = score;
      overlayEl.textContent = "GAME OVER (R)";
      overlayEl.classList.add('show');
      showToast("ËèúÂ∞±Â§öÁªÉ");
setTimeout(() => {
  if(gameOver){
    gameOverPendingSave = true;
    summaryShown = true;
    openSummaryModal();
  }
}, 1350);
    }
  }

  function canPlace(p, dx, dy, dr){
    const rots = rotations[p.kind];
    const nr = (p.r + dr + rots.length) % rots.length;
    for(const [cy,cx] of rots[nr]){
      const x = p.x + dx + cx;
      const y = p.y + dy + cy;
      if(x<0 || x>=W || y<0 || y>=H) return false;
      if(board[y][x]) return false;
    }
    return true;
  }
  // Reveal the next piece at the very top (visual-only) once the current piece reaches row 4.
// Row 4 from top = y >= 3 (0-based).
function maybeRevealNext(){
  if(gameOver || paused || stageCleared) return;
  if(!piece) return;
  if(nextReveal) return;
  if(typeof nextKind === 'undefined' || nextKind === null) return;

  if(piece.y >= 3){
    nextReveal = true;
    nextWaitingPiece = { kind: nextKind, r: 0, x: 3, y: 0 };
    // (next-pop flash removed; now only flash on hard drop)
  }
}

// Flash the board ONLY for hard drop (Space / DROP)
function flashHardDrop(){
  const boardEl = document.querySelector('.board');
  if(!boardEl) return;
  boardEl.classList.remove('drop-pop');
  // force reflow to restart animation
  void boardEl.offsetWidth;
  boardEl.classList.add('drop-pop');
  setTimeout(() => boardEl.classList.remove('drop-pop'), 280);
}

  function lock(){
    piecesLocked++;
    // ËÆ∞ÂΩïÈîÅÂùóÂâçÂàÜÊï∞ÔºàÁ°¨Èôç/ËΩØÈôçÂä†ÂàÜÂ∑≤ËÆ°ÂÖ•ÔºâÔºåÁî®‰∫é‚ÄúÁªßÁª≠Ê∏∏Êàè‚ÄùÂõûÈÄÄ
lockScoreHistory.push(score);
if(lockScoreHistory.length > 80) lockScoreHistory.shift();
    for(const [cy,cx] of rotations[piece.kind][piece.r]){
      board[piece.y+cy][piece.x+cx] = piece.kind;
    }
      // ‚úÖ Â§©Êô¥Â∞èÂÆùË¥ùÔºöÂè™Ë¶ÅÂú®‰ªªÊÑè‰∏ÄË°åÂá∫Áé∞ A Q X P K ËøûÂú®‰∏ÄËµ∑Ôºà‰∏çË¶ÅÊ±ÇÊª°Ë°åÔºâ=> ÂÖ®Â±èÊ∏ÖÈô§Âä®Áîª
  if(triggerPhraseClearAll()){
    // ËøôÊ¨°ÈîÅÂùó‰∏çËµ∞ÊôÆÈÄöÊ∂àË°åÈÄªËæë
    return;
  }
    const didClear = clearLines();
    if(!didClear){
      // no line clear -> combo breaks
      combo = 0;
      spawn(); // Ê≤°Ê∂àÈô§ÊâçÁ´ãÂàªÂá∫‰∏ã‰∏ÄÂùó
    }
  }
function kindToRgb(k){
  if(k === 'I') return '34,211,238';
  if(k === 'O') return '250,204,21';
  if(k === 'T') return '168,85,247';
  if(k === 'S') return '34,197,94';
  if(k === 'Z') return '239,68,68';
  if(k === 'J') return '59,130,246';
  if(k === 'L') return '249,115,22';
  if(k === 'G') return '140,200,255';
  if(k === 'E') return '168,85,247';
  if(k === 'M') return '200,210,225';
  if(k === 'R') return '220,228,240';
  if(k === 'B') return '239,68,68';
  if(k === 'C') return '56,189,248';
  return '255,255,255';
}

// Á≤íÂ≠êÁàÜÊï£ÊïàÊûúÔºàÊåâÊØèÊ†ºÈ¢úËâ≤Ôºâ
function spawnParticlesForRow(rowY, kinds){
  const boardEl = document.querySelector('.board');
  if(!boardEl) return;

  const rect = boardEl.getBoundingClientRect();
  const cellSize = rect.width / 10;

  for(let x = 0; x < 10; x++){
    const k = (Array.isArray(kinds) && kinds[x]) ? kinds[x] : null;
    const rgb = kindToRgb(k);

    // Glass: more particles + shard look. Others: keep original feel.
    const isGlass = (k === 'G');
    const count = isGlass ? 12 : 4;

    for(let i = 0; i < count; i++){
      const p = document.createElement('div');
      p.className = 'particle';

      const px = x * cellSize + cellSize / 2;
      const py = rowY * cellSize + cellSize / 2;

      // Wider spread for glass shards
      const dx = (Math.random() - 0.5) * (isGlass ? 170 : 120);
      const dy = -Math.random() * (isGlass ? 220 : 160);

      p.style.left = px + 'px';
      p.style.top  = py + 'px';
      p.style.setProperty('--dx', dx + 'px');
      p.style.setProperty('--dy', dy + 'px');
      p.style.setProperty('--prgb', rgb);

      // Glass shard styling (visual-only)
      if(isGlass){
        const w = 3 + Math.random() * 5;     // 3‚Äì8
        const h = 2 + Math.random() * 6;     // 2‚Äì8
        p.style.width  = w + 'px';
        p.style.height = h + 'px';
        p.style.borderRadius = '2px';
        p.style.boxShadow = '0 0 14px rgba(180,220,255,.22)';
        p.style.setProperty('--rot', (Math.random() * 160 - 80).toFixed(1) + 'deg');
      }else{
        p.style.setProperty('--rot', '0deg');
      }

      boardEl.appendChild(p);
      setTimeout(() => p.remove(), 500);
    }
  }
}

// Bomb blast ring (visual)
function spawnBombBlastAt(x, y){
  const boardEl = document.querySelector('.board');
  if(!boardEl) return;
  const rect = boardEl.getBoundingClientRect();
  const cellSize = rect.width / 10;

  const px = x * cellSize + cellSize / 2;
  const py = y * cellSize + cellSize / 2;

  const el = document.createElement('div');
  el.className = 'bomb-blast';
  el.style.setProperty('--bx', px + 'px');
  el.style.setProperty('--by', py + 'px');
  boardEl.appendChild(el);
  setTimeout(() => el.remove(), 1500);
}
// Ice gravity: let 2x2 ice blocks fall as intact bodies (never split)
function applyIceGravity(){
  let movedAny = false;

  // multiple passes to settle stacks
  for(let pass = 0; pass < 30; pass++){
    let moved = false;

    // scan bottom-up so lower blocks settle first
    for(let y = H - 2; y >= 0; y--){
      for(let x = 0; x <= W - 2; x++){
        // detect a 2x2 ice block with (x,y) as top-left
        if(board[y][x] !== 'C') continue;
        if(board[y][x+1] !== 'C' || board[y+1][x] !== 'C' || board[y+1][x+1] !== 'C') continue;


        // can drop 1 step?
        const by = y + 2; // cells below the bottom row
        if(by >= H) continue;
        if(board[by][x] || board[by][x+1]) continue;

        // move down by 1
        board[y][x] = null;
        board[y][x+1] = null;
        board[y+1][x] = null;
        board[y+1][x+1] = null;

        board[y+1][x] = 'C';
        board[y+1][x+1] = 'C';
        board[y+2][x] = 'C';
        board[y+2][x+1] = 'C';

        moved = true;
        movedAny = true;
      }
    }

    if(!moved) break;
  }

  return movedAny;
}
// Basic gravity: drop single cells straight down (skip ice 'C' because it's handled as 2x2 bodies)
function applyBasicGravity(){
  let movedAny = false;

  // bottom-up so stacks settle correctly
  for(let y = H - 2; y >= 0; y--){
    for(let x = 0; x < W; x++){
      const v = board[y][x];
      if(!v) continue;
      if(v === 'C') continue; // ice stays as 2x2 via applyIceGravity()

      let ny = y;
      while(ny + 1 < H && !board[ny + 1][x]){
        ny++;
      }
      if(ny !== y){
        board[ny][x] = v;
        board[y][x] = null;
        movedAny = true;
      }
    }
  }
  return movedAny;
}

// Apply gravity for ALL modes: ice first (2x2), then normal cells; repeat until settled
function applyAllGravity(){
  let movedAny = false;

  for(let pass = 0; pass < 30; pass++){
    const mIce = applyIceGravity();
    const mBasic = applyBasicGravity();
    if(!(mIce || mBasic)) break;
    movedAny = movedAny || mIce || mBasic;
  }
  return movedAny;
}

  function clearLines(){
    // ÊâæÂá∫Êª°Ë°å
    const full = [];
    for(let y=0;y<H;y++){
  let ok = true;
  for(let x=0;x<W;x++){
    if(!board[y][x]) { ok = false; break; }
  }
  if(ok) full.push(y);
}

    if(full.length === 0) return false;

    // ===== Energy rule (chain) =====
    // ËßÑÂàôÔºöÂè™Ë¶ÅÊú¨Ê¨°Ë¶ÅÊ∏ÖÊéâÁöÑË°åÈáåÊúâ‰ªª‰Ωï EÔºà‰∏çËÆ∫ÂÆÉÊù•Ëá™Êª°Ë°åËøòÊòØÈ¢ùÂ§ñÊ∏ÖË°åÔºâÔºåÂ∞±ÊääËØ•Ë°åÁöÑ‰∏ä‰∏ÄË°å+‰∏ã‰∏ÄË°å‰πüÂä†ÂÖ•Ê∏ÖÈô§„ÄÇ
    // ÂÖÅËÆ∏ËøûÈîÅÔºöÊñ∞Â¢ûÁöÑË°åÂ¶ÇÊûú‰πüÂåÖÂê´ EÔºå‰ºöÁªßÁª≠Êâ©Êï£„ÄÇ
    const toClear = new Set(full);

    let changed = true;
    while(changed){
      changed = false;
      for(const y of Array.from(toClear)){
        // Ëøô‰∏ÄË°åÂ¶ÇÊûúÂ≠òÂú®ËÉΩÈáèÂùó EÔºåÂàôÊâ©Êï£Âà∞‰∏ä‰∏ãË°å
        if(board[y] && board[y].some(v => v === 'E')){
          const a = y - 1;
          const b = y + 1;
          if(a >= 0 && !toClear.has(a)) { toClear.add(a); changed = true; }
          if(b < H && !toClear.has(b)) { toClear.add(b); changed = true; }
        }
      }
    }

    // Ice CAN participate in making a row full, but ice cells themselves are not removed.
const rowsToClear = Array.from(toClear).sort((a,b) => a-b);
    // ===== Detect Energy trigger for this clear =====
    const energyTriggered = rowsToClear.some(y => board[y] && board[y].some(v => v === 'E'));
    const bombTriggered = rowsToClear.some(y => board[y] && board[y].some(v => v === 'B'));

    if(energyTriggered){
      // Energy: stronger slow-mo + staggered shatter
      slowMoFactor = 1.55;             // ÊÖ¢Âä®‰ΩúÂÄçÁéáÔºàË∂äÂ§ßË∂äÊÖ¢Ôºâ
      slowMoUntil  = Date.now() + 760; // ÊåÅÁª≠Êó∂Èó¥ ms
      energyClearActive = true;

      document.documentElement.style.setProperty('--clear-dur', '0.42s');
      document.documentElement.style.setProperty('--energy-stagger', '58ms');
    }else if(bombTriggered){
      // Bomb: slow-mo, but NOT the same shatter style as Energy
      slowMoFactor = 1.25;
      slowMoUntil  = Date.now() + 1050;
      energyClearActive = false;

      document.documentElement.style.setProperty('--clear-dur', '0.48s');
      document.documentElement.style.setProperty('--energy-stagger', '46ms');
    }else{
      energyClearActive = false;
      document.documentElement.style.setProperty('--clear-dur', '0.28s');
      document.documentElement.style.setProperty('--energy-stagger', '46ms');
    }

    // ËøõÂÖ•Ê∂àÈô§Âä®ÁîªÁä∂ÊÄÅ
    clearing = true;
    clearingRows = new Set(rowsToClear);
    // ‰ªçÁÑ∂Áî® 1-4 Ê°£ÁöÑÈó™ÂÖâÂº∫Â∫¶ÔºàË∂ÖËøá 4 Ë°å‰πüÊåâ 4 Ë°åÂº∫Â∫¶Ôºâ
    clearingCount = Math.min(4, rowsToClear.length);

    // snapshot row kinds before animation removes them
    const clearKinds = rowsToClear.map(y => board[y].slice());

    // Snapshot bomb positions (no chain). Bomb explodes when it is removed by this clear.
    const bombCells = [];
    for(const y of rowsToClear){
      for(let x = 0; x < W; x++){
        if(board[y] && board[y][x] === 'B') bombCells.push([x, y]);
      }
    }

    // Êí≠ÊîæÂä®Áîª‰∏ÄÂ∞èÊÆµÊó∂Èó¥ÂêéÔºåÂÜçÁúüÊ≠£Âà†Èô§Ë°å
    setTimeout(() => {
      // Á≤íÂ≠êÁàÜÊï£ÊïàÊûúÔºàÊåâÊØèÊ†ºÈ¢úËâ≤Ôºâ
      for(let i = 0; i < rowsToClear.length; i++){
        spawnParticlesForRow(rowsToClear[i], clearKinds[i]);
      }

      // ===== Bomb rule (explode and clear neighbors 1 cell) =====
      // Triggered when a bomb cell is removed by this clear.
      // Clears surrounding 1-cell area, but does NOT chain additional clears.
      if(bombCells.length){
        for(const [bx, by] of bombCells){
          // If this bomb is about to be removed (row is being cleared), play blast.
          spawnBombBlastAt(bx, by);

          // Clear ONLY vertical neighbors: self + up 1 cell + down 1 cell (no area / no extra rows)
          const targets = [[bx, by], [bx, by - 1], [bx, by + 1]];
          for(const [x, y] of targets){
            if(x < 0 || x >= W || y < 0 || y >= H) continue;
            const v = board[y][x];
            if(v === 'M' || v === 'R') continue;
            board[y][x] = null;
          }
        }
      }

      // ===== Metal rule (2-hit clear) =====
      // M = dark metal (first life), R = light metal (second life)
      // - If a cleared row contains any M: first hit -> keep metal, turn M -> R, clear the other cells in that row.
      //   This does NOT count as a line clear and gives NO points.
      // - If a cleared row contains any R: second hit -> remove it like normal clear.
      // - When any R is fully removed in this clear, the score for this clear is x4.
      const toDelete = new Set();
let metalSecondHit = false;

// ‚úÖ ËÆ°ÂàÜ/lines Áî®ÔºöÂåÖÂê´‚ÄúÂÜ∞ÂùóÂèÇ‰∏éÊ∂àË°å‰ΩÜ‰∏çÊ∂àÊú¨Ë∫´‚ÄùÁöÑÈÇ£‰∫õË°å
let clearedForScore = 0;

for(const y of rowsToClear){
  const row = board[y];
  if(!row) continue;

  const hasC = row.some(v => v === 'C');   // ‚úÖ ÂÜ∞Âùó
  const hasM = row.some(v => v === 'M');   // ÈáëÂ±û1ÂëΩ
  const hasR = row.some(v => v === 'R');   // ÈáëÂ±û2ÂëΩ

  // ===== Metal rule (first hit) =====
  if(hasM){
    // first hit: keep metal blocks, lighten them, clear others
    for(let x = 0; x < W; x++){
      if(board[y][x] === 'M') board[y][x] = 'R';
      else board[y][x] = null;
    }
    // ‚ùóÊúâ M ÁöÑË°åÔºö‰∏çÁÆóÁúüÊ≠£Ê∂àË°å„ÄÅ‰∏çÂä†ÂàÜÔºà‰øùÊåÅ‰Ω†ÂéüËßÑÂàôÔºâ
    continue;
  }

  // ===== Ice rule =====
  // ‚úÖ ÂÜ∞ÂùóÂèØ‰ª•ËÆ©Ëøô‰∏ÄË°å‚ÄúÁÆóÊ∂àË°å‚ÄùÔºå‰ΩÜ C Êú¨Ë∫´‰∏çÊ∂àÂ§±
  if(hasC){
    // ËøôË°å‰∏çÂà†Èô§ÔºåÂè™Ê∏ÖÊéâÈùû C
    for(let x = 0; x < W; x++){
      if(board[y][x] !== 'C') board[y][x] = null;
    }
    // Ëøô‰∏ÄË°åÁÆó‰Ωú‚ÄúÊ∂àË°å‚ÄùÔºàÂä† lines/Âä†ÂàÜÔºâ
    clearedForScore++;

    // Â¶ÇÊûúËøôË°åÈáåÊúâ RÔºåË¢´Ê∏ÖÊéâ‰∫Ü -> Ëß¶Âèë x4
    if(hasR) metalSecondHit = true;

    // ‰∏ç toDelete
    continue;
  }

  // ===== Normal delete (includes second-hit metal) =====
  if(hasR) metalSecondHit = true;
  toDelete.add(y);
  clearedForScore++;
}

// Delete rows that are truly cleared
board = board.filter((_, y) => !toDelete.has(y));
while(board.length < H) board.unshift(Array(W).fill(null));

if(noobMode){
  // ËèúÈ∏°ÔºöÂçïÊ†ºÂÉèÊ≤ôÂ≠ê‰∏ÄÊ†∑ÊéâÔºà‰øùÊåÅ‰Ω†Áé∞Âú®ÁöÑÔºâ
  applyNoobGravity();
} else {
  // ÂÖ∂‰ªñÊ®°ÂºèÔºöÊï¥ÂùóÊï¥‰ΩìÂæÄ‰∏ãÊéâ
  applyRigidGravity();
}

// ÂÜ∞Âùó‰øùÊåÅ 2x2 Êï¥‰Ωì‰∏ãËêΩÔºà‰Ω†ÂéüÊú¨ÁöÑËßÑÂàôÔºâ
applyIceGravity();
// ‚úÖ ËÆ°ÂàÜ/ÂçáÁ∫ßÔºöÁî® clearedForScoreÔºàÂÜ∞ÂùóË°å‰πüÁÆóÔºâ
const cleared = clearedForScore;
const metalMultiplier = metalSecondHit ? 4 : 1;
      

      // ===== COMBO =====
      combo = (combo || 0) + 1;
      if(combo >= 2){
        showToast(`COMBO x${combo}`, 'combo');
      }

      // ===== Back-to-Back (Tetris only) =====
      if(cleared === 4){
        if(b2bEligible){
          b2bStreak = (b2bStreak || 1) + 1;
        }else{
          b2bStreak = 1;
        }
        b2bEligible = true;
        if(b2bStreak >= 2) showToast(`B2B x${b2bStreak}`, 'b2b');
        else showToast('TETRIS!', 'tetris');
      }else{
        b2bEligible = false;
        b2bStreak = 0;
      }

      lines += cleared;
      score += ((lineScore[cleared] || 0) * level) * metalMultiplier;
      if(metalSecondHit && cleared > 0){
        showToast(`x${metalMultiplier} SCORE!`, 'metal');
      }
      if(proMode) level = 1 + Math.floor(lines/2);

      // ===== PERFECT CLEAR =====
      const isPerfectClear = board.every(row => row.every(v => !v));
      if(isPerfectClear){
        showToast('PERFECT CLEAR', 'pc');
        // Perfect clear also feels like a combo highlight; keep combo as-is
      }

      updateHUD();
      checkStage();

      // ÈÄÄÂá∫Ê∂àÈô§Áä∂ÊÄÅ
      clearing = false;
      clearingRows = new Set();
      clearingCount = 0;

      // ÁªßÁª≠ÁîüÊàê‰∏ã‰∏ÄÂùóÔºàÈáçË¶ÅÔºöËøôÈáåÂÜç spawnÔºâ
      spawn();
    }, energyTriggered ? 420 : 280);// Âíå CSS Âä®ÁîªÊó∂Èó¥ÂåπÈÖçÔºà.28sÔºâ

    return true;
  }
function applyNoobGravity(){
  // ÊØè‰∏ÄÂàóÊääÊñπÂùó‚ÄúÂéãÂÆû‚ÄùÂà∞ÊúÄÂ∫ï‰∏ãÔºàÂÉèÊ≤ôÂ≠ê‰∏ÄÊ†∑Áõ¥ËêΩÔºâ
  for(let x=0; x<W; x++){
    let writeY = H - 1;
    for(let y = H - 1; y >= 0; y--){
      if(board[y][x]){
        if(y !== writeY){
          board[writeY][x] = board[y][x];
          board[y][x] = null;
        }
        writeY--;
      }
    }
  }
}
// ===== Rigid gravity: drop connected components as whole bodies =====
// ËßÑÂàôÔºöÂêå‰∏ÄÁßçÊñπÂùó(kind)ËøûÂú®‰∏ÄËµ∑(‰∏ä‰∏ãÂ∑¶Âè≥)ÁÆó‰∏Ä‰∏™‚ÄúÊï¥‰ΩìÂõæÂΩ¢‚ÄùÔºåÊï¥‰Ωì‰∏ãËêΩÔºåÁªù‰∏çÊï£ÊàêÂçïÊ†º
function applyRigidGravity(){
  let movedAny = false;

  for(let pass = 0; pass < 30; pass++){
    // 1) ÊâæÊâÄÊúâÁªÑ‰ª∂ÔºàÂêå kind ÁöÑËøûÈÄöÂùóÔºâ
    const visited = Array.from({length:H}, () => Array(W).fill(false));
    const comps = [];

    for(let y=0; y<H; y++){
      for(let x=0; x<W; x++){
        const v = board[y][x];
        if(!v) continue;
        if(v === 'C') continue; // ÂÜ∞ÂùóÁî®‰Ω†Ëá™Â∑±ÁöÑ 2x2 ÈÄªËæëÂ§ÑÁêÜ
        if(visited[y][x]) continue;

        // BFS/DFS
        const kind = v;
        const stack = [[x,y]];
        visited[y][x] = true;
        const cells = [];
        let maxY = y;

        while(stack.length){
          const [cx,cy] = stack.pop();
          cells.push([cx,cy]);
          if(cy > maxY) maxY = cy;

          const neigh = [[cx-1,cy],[cx+1,cy],[cx,cy-1],[cx,cy+1]];
          for(const [nx,ny] of neigh){
            if(nx<0||nx>=W||ny<0||ny>=H) continue;
            if(visited[ny][nx]) continue;
            if(board[ny][nx] !== kind) continue;
            visited[ny][nx] = true;
            stack.push([nx,ny]);
          }
        }

        comps.push({ kind, cells, maxY });
      }
    }

    if(comps.length === 0) break;

    // 2) ËÆ°ÁÆóÊØè‰∏™ÁªÑ‰ª∂ËÉΩÊï¥‰Ωì‰∏ãËêΩÂ§öÂ∞ëÊ†º
    // ‰∏∫‰∫Ü‰∏ç‰∫íÁõ∏Âπ≤Êâ∞ÔºöÂÖàÁÆó dropÔºàÂü∫‰∫éÂΩìÂâç boardÔºâÔºåÂÜçÊåâ maxY ‰ªé‰ΩéÂà∞È´òÔºàÂ∫ïÈÉ®‰ºòÂÖàÔºâÂ∫îÁî®
    // ÂÅö‰∏Ä‰∏™Âø´ÈÄüÊü•ÊâæÔºöÊüêÊ†ºÊòØÂê¶Â±û‰∫éËØ•ÁªÑ‰ª∂
    const drops = comps.map(comp => {
      const set = new Set(comp.cells.map(([x,y]) => `${x},${y}`));
      let d = Infinity;

      for(const [x,y] of comp.cells){
        let step = 0;
        while(true){
          const ny = y + step + 1;
          if(ny >= H) break;
          const below = board[ny][x];
          if(below && !set.has(`${x},${ny}`)) break; // ÊíûÂà∞Âà´ÁöÑÂùó
          step++;
        }
        d = Math.min(d, step);
        if(d === 0) break;
      }
      return { comp, set, drop: (d === Infinity ? 0 : d) };
    });

    // 3) Â∫îÁî®ÁßªÂä®ÔºàÂ∫ïÈÉ®ÁªÑ‰ª∂ÂÖàÁßªÂä®ÔºåÈÅøÂÖçË¶ÜÁõñÔºâ
    drops.sort((a,b) => b.comp.maxY - a.comp.maxY);

    let movedThisPass = false;

    for(const item of drops){
      const { comp, drop } = item;
      if(drop <= 0) continue;

      // Ê∏ÖÁ©∫Âéü‰ΩçÁΩÆ
      for(const [x,y] of comp.cells){
        board[y][x] = null;
      }
      // ÂÜôÂÖ•Êñ∞‰ΩçÁΩÆ
      for(const [x,y] of comp.cells){
        board[y + drop][x] = comp.kind;
      }

      movedThisPass = true;
      movedAny = true;
    }

    if(!movedThisPass) break;
  }

  return movedAny;
}
  function ghostY(){
    let y = piece.y;
    while(canPlace(piece, 0, (y-piece.y)+1, 0)) y++;
    return y;
  }

  function hardDrop(){
    hardDrops++;
    const gy = ghostY();
    score += Math.max(0, gy - piece.y) * 2;
    piece.y = gy;
    updateHUD();
    checkStage();
    checkEndlessCap();
    maybeRevealNext();
    lock();
    flashHardDrop();
  }

  function stageTargetFor(s){
  return 500 + (s-1)*300;
}
function baseScoreForStage(s){
  // ÂΩìÂâçÂÖ≥Âç°ÁöÑÂü∫Á°ÄÂàÜ = ‰∏ä‰∏ÄÂÖ≥ÈÄöÂÖ≥ÂàÜÔºõÁ¨¨1ÂÖ≥Âü∫Á°ÄÂàÜ=0
  if(!s || s <= 1) return 0;
  return stageTargetFor(s - 1);
}
function stageIntervalFor(s){
  // ÊØèÂÖ≥Âõ∫ÂÆö‰∏Ä‰∏™ÈÄüÂ∫¶ÔºàË∂äÂæÄÂêéË∂äÂø´ÔºâÔºåÊÉ≥Êõ¥Âø´/Êõ¥ÊÖ¢Â∞±ÊîπËøôÈáå
  return Math.max(0.12, 0.60 - (s-1)*0.05);
}

function updateHUD(){
  scoreEl.textContent = score;
  levelEl.textContent = level;
  linesEl.textContent = lines;
  if(stageEl) stageEl.textContent = stage;

  if(hudScoreEl) hudScoreEl.textContent = score;
  if(hudLevelEl) hudLevelEl.textContent = level;
  if(hudLinesEl) hudLinesEl.textContent = lines;
  if(hudStageEl) hudStageEl.textContent = stage;
}

  function draw(){
    if(phraseClearActive) return;
    // reset all
    for(const c of cells){ c.className = 'cell'; }

    // settled
    // settled
    for(let y=0;y<H;y++){
  for(let x=0;x<W;x++){
    const v = board[y][x]; // "I"..."L" or null
    if(v){
      const idx = y*W+x;
      const cell = cells[idx];
cell.classList.add('filled');
cell.classList.add('kind-' + v);

if(clearingAll || clearingRows.has(y)){
  cell.classList.add('clearing');
  if(clearingCount >= 1 && clearingCount <= 4) cell.classList.add('clear-' + clearingCount);

  if(energyClearActive && clearingRows.has(y)){
    if(v === 'E'){
      cell.classList.add('energy-first');
      cell.classList.remove('energy-late');
      cell.style.setProperty('--ad', '0ms');
    }else{
      cell.classList.add('energy-late');
      cell.classList.remove('energy-first');
      // ‚Äú‰∏Ä‰∏™‰∏™Á¢éÊéâ‚ÄùÔºöÊåâÂàóÈîôÂ≥∞Ôºà0~9ÔºâÔºåËÉΩÁúãÂá∫Êù•‰ΩÜ‰∏çÊÖ¢
      const d = x * 18; // ms
      cell.style.setProperty('--ad', `calc(var(--energy-stagger, 46ms) + ${d}ms)`);
    }
  }else{
    cell.classList.remove('energy-first','energy-late');
    cell.style.removeProperty('--ad');
  }
}else{
  cell.classList.remove('energy-first','energy-late');
  cell.style.removeProperty('--ad');
}
    }
  }
}

    if(!gameOver){
      // waiting next (visual-only, shown at the very top)
if(nextReveal && nextWaitingPiece){
  const rots = rotations[nextWaitingPiece.kind];
  const r = 0;
  for(const [cy,cx] of rots[r]){
    const y = nextWaitingPiece.y + cy;
    const x = nextWaitingPiece.x + cx;
    if(y >= 0 && y < H && x >= 0 && x < W){
      if(!board[y][x]){
  const cell = cells[y*W+x];
  cell.classList.add('next');
  cell.classList.add('kind-' + nextWaitingPiece.kind);
}
    }
  }
}
      // ghost
      const gy = ghostY();
      for(const [cy,cx] of rotations[piece.kind][piece.r]){
        const y = gy+cy, x = piece.x+cx;
        const idx = y*W+x;
        if(!board[y][x]){
          cells[idx].classList.add('ghost');
          cells[idx].classList.add('kind-' + piece.kind);
        }
      }
      // active
      for(const [cy,cx] of rotations[piece.kind][piece.r]){
  const y = piece.y+cy, x = piece.x+cx;
  const cell = cells[y*W+x];
  cell.classList.add('filled');
  cell.classList.add('kind-' + piece.kind);
}
    }
  }

  function togglePause(){
    if(gameOver) return;
    paused = !paused;
    overlayEl.textContent = paused ? "PAUSED" : "";
    overlayEl.classList.toggle('show', paused);
  }

  function reset(){
    board = Array.from({length:H}, () => Array(W).fill(null));
    score=0; lines=0; level=1;
    piecesLocked = 0;
hardDrops = 0;
softDrops = 0;
gameStartAt = Date.now();
closeSummaryModal();
savedThisGame = false;
resetModeTrail();
gameOverPendingSave = false;
summaryShown = false;
scoreBeforeGameOver = 0;
lockScoreHistory = [];
nextReveal = false;
nextWaitingPiece = null;
paused=false; gameOver=false;
    stageCleared = false;
  clearingAll = false;
  closeStageModal();
    overlayEl.classList.remove('show');
    overlayEl.textContent = "PAUSED";
    bag = [];
    nextKind = null;
    updateHUD();
    spawn();
  }

  // main loop
  let last = performance.now();
  let acc = 0;
  function tick(t){
    const dt = (t-last)/1000;
    last = t;

    if(!paused && !gameOver){
  if(!clearing){
    acc += dt;
    const baseInterval = proMode
  ? Math.max(0.08, 0.4 - (level-1)*0.015)   // ‰Ω†ÂéüÊù•ÁöÑÊú∫Âà∂
  : stageIntervalFor(stage);                 // ÂÖ≥Âç°Âõ∫ÂÆöÈÄüÂ∫¶

    const nowMs = Date.now();
    const slowFactor = (nowMs < slowMoUntil) ? slowMoFactor : 1;

    let interval = baseInterval * mercyMultiplier * slowFactor;
    // Ice piece falls slower
    if(piece && piece.kind === 'C') interval *= 1.45;

    if(acc >= interval){
      acc = 0;
      if(canPlace(piece,0,1,0)) piece.y += 1;
      else lock();
    }
  }
  maybeRevealNext();
  draw(); // ‚úÖ ‰∏çÁÆ° clearing ‰∏éÂê¶ÈÉΩÁîªÔºåËøôÊ†∑Âä®Áîª‰∏ÄÁõ¥Êí≠Êîæ
}
    requestAnimationFrame(tick);
  }

  // controls (keyboard + mobile)
  function tryRotate(dr){
  if(!piece) return false;

  // ÁÆÄÂåñÁâà wall-kickÔºöÂéüÂú∞ËΩ¨‰∏ç‰∫ÜÂ∞±Â∞ùËØïÊå™‰∏Ä‰∏ãÂÜçËΩ¨
  const kicks = [
    [0,0],
    [-1,0],[1,0],
    [-2,0],[2,0],
    [0,-1],
    [-1,-1],[1,-1]
  ];

  for(const [kx,ky] of kicks){
    if(canPlace(piece, kx, ky, dr)){
      const rots = rotations[piece.kind];
      piece.r = (piece.r + dr + rots.length) % rots.length;
      piece.x += kx;
      piece.y += ky;
      return true;
    }
  }
  return false;
}
  function handleControl(code){
    if(code === 'KeyP'){ togglePause(); return; }
    if(code === 'KeyR'){
  // ÈîÆÁõò R ÈáçÂºÄ‰πüÁÆó‰∏ÄÂ±ÄÁªìÊùüÔºåÂÖàÂ≠ò‰∏ÄÊ¨°
  if(started && !gameOver) saveRunOnce();
  reset();
  return;
}
    if(code === 'KeyQ'){ return; }
    if(!started || paused || gameOver || stageCleared) return;

    if(code === 'ArrowLeft'){
      if(canPlace(piece,-1,0,0)) piece.x -= 1;
    } else if(code === 'ArrowRight'){
      if(canPlace(piece, 1,0,0)) piece.x += 1;
    } else if(code === 'ArrowDown'){
      if(canPlace(piece,0,1,0)) { piece.y += 1; score += 1; softDrops++; updateHUD(); checkStage(); checkEndlessCap(); maybeRevealNext(); }
      else lock();
    } else if(code === 'ArrowUp'){
  tryRotate(1);

} else if(code === 'KeyZ'){
  tryRotate(-1);
} else if(code === 'Space'){
  hardDrop();
}
    maybeRevealNext();
draw();

  }

  window.addEventListener('keydown', (e) => {
    // Èò≤Ê≠¢ÊâãÊú∫Â§ñÊé•ÈîÆÁõò/ÁîµËÑëÊµèËßàÂô®ÊåâÁ©∫Ê†ºÊªöÂä®
    if(e.code === 'Space') e.preventDefault();
    handleControl(e.code);
  });

  // ===== Mobile buttons =====
  const mctl = document.getElementById('mobileControls');
  let repeatTimer = null;
  // ===== Auto reserve space for mobile controls (FIXED) =====
function updateBottomSpace(){
  const m = document.getElementById('mobileControls');
  if(!m) return;

  const rect = m.getBoundingClientRect();
  const gap = 12; // ÊÉ≥Êõ¥Á¥ßÂ∞± 8ÔºåÊõ¥ÊùæÂ∞± 16
  const pad = Math.ceil(rect.height + gap);

  document.documentElement.style.setProperty('--mctl-pad', pad + 'px');
}

// ÂêØÂä®/Á™óÂè£ÂèòÂåñ/ÊóãËΩ¨ÈÉΩÊõ¥Êñ∞
updateBottomSpace();
window.addEventListener('resize', updateBottomSpace);
window.addEventListener('orientationchange', updateBottomSpace);
  function startRepeat(code, ms){
    stopRepeat();
    handleControl(code); // ÂÖàËß¶Âèë‰∏ÄÊ¨°
    repeatTimer = setInterval(() => handleControl(code), ms);
  }
  function stopRepeat(){
    if(repeatTimer){ clearInterval(repeatTimer); repeatTimer = null; }
  }

  if(mctl){
    const actToCode = (act) => {
      if(act === 'left') return 'ArrowLeft';
      if(act === 'right') return 'ArrowRight';
      if(act === 'down') return 'ArrowDown';
      if(act === 'rotate') return 'ArrowUp';
      if(act === 'drop') return 'Space';
      if(act === 'pause') return 'KeyP';
      return null;
    };

    // Èò≤Ê≠¢Ëß¶ÊéßÊªëÂä®È°µÈù¢
    mctl.addEventListener('touchmove', (e) => e.preventDefault(), {passive:false});

    mctl.querySelectorAll('button[data-act]').forEach(btn => {
      const act = btn.dataset.act;
      const code = actToCode(act);

      const onDown = (e) => {
  e.preventDefault();

  // ‚úÖ Âè™Êúâ GAME OVER ÂêéÔºåÁÇπÊâãÊú∫ DROP ÊâçÈáçÂºÄÂπ∂‰øùÁïôÂàöÊâçÁöÑ stage/levelÔºàÈÄüÂ∫¶Ôºâ
  if(act === 'drop' && gameOver && summaryShown){
    if(gameOverPendingSave){
      saveRunOnce();
      gameOverPendingSave = false;
    }

    const keepStage = stage;
    const keepLevel = level;

    closeSummaryModal();
    reset();            // ‰ºöÊää level/stage Ê∏ÖÂõû 1
    stage = keepStage;  // ÊÅ¢Â§çÂÖ≥Âç°
    level = keepLevel;  // ÊÅ¢Â§çÁ≠âÁ∫ßÔºàÈÄüÂ∫¶Ôºâ
    updateHUD();

    paused = false;
    overlayEl.classList.remove('show');
    overlayEl.textContent = "";
    summaryShown = false;
    return;
  }

  if(!code) return;

  // Â∑¶/Âè≥/‰∏ãÔºöÈïøÊåâËøûÂèë
  if(code === 'ArrowLeft' || code === 'ArrowRight') startRepeat(code, 90);
  else if(code === 'ArrowDown') startRepeat(code, 60);
  else handleControl(code); // ÊóãËΩ¨/Á°¨Èôç/ÊöÇÂÅúÔºöÁÇπ‰∏Ä‰∏ãÂç≥ÂèØ
};

      const onUp = (e) => {
        e.preventDefault();
        stopRepeat();
      };

      btn.addEventListener('touchstart', onDown, {passive:false});
      btn.addEventListener('touchend', onUp, {passive:false});
      btn.addEventListener('touchcancel', onUp, {passive:false});

      // ÁîµËÑë‰∏ä‰πüËÉΩÁÇπ
      btn.addEventListener('mousedown', onDown);
      btn.addEventListener('mouseup', onUp);
      btn.addEventListener('mouseleave', onUp);
      btn.addEventListener('click', (e) => e.preventDefault());
    });
  }
  // block double-tap zoom (iOS)
let lastTouchEnd = 0;
document.addEventListener('touchend', (e) => {
  const now = Date.now();
  if(now - lastTouchEnd <= 300) e.preventDefault();
  lastTouchEnd = now;
}, { passive: false });
function turnOffAllModes(){
  // ÂÖ≥Ê±ÇÈ•∂
  if(mercyOn) setMercy(false);

  // ÂÖ≥ÂÖ∂‰ªñÊ®°Âºè
  proMode = false;
  noobMode = false;
  endlessMode = false;
  endlessLocked = false;
  closeEndlessModal?.();
  overlayEl.classList.remove('show');
  overlayEl.textContent = "";

  // ËøòÂéüÊåâÈíÆÊñáÂ≠óÔºàÊåâ‰Ω†Áé∞Âú®ÁöÑÊñáÊ°àÂÜôÔºâ
  if(btnPro) btnPro.textContent = 'Â§ßÁ•ûÊ®°Âºè ‚ö°ÔºàÊÖ¢ÊÖ¢ÂèòÂø´Ôºâ';
  if(btnNoob) btnNoob.textContent = 'ËèúÈ∏°Ê®°Âºè üê£ÔºàÊÇ¨Á©∫Ëá™Âä®ËêΩÔºâ';
  if(btnEndless) btnEndless.textContent = 'Êó†Â∞ΩÊ®°Âºè ‚ôæÔ∏èÔºàÁàΩÊ≠ª‰Ω†Ôºâ';
  applyThemeByMode();
}
btnNormal?.addEventListener('click', () => {
  requestModeChange('normal');
  applyThemeByMode();
});

btnPro?.addEventListener('click', () => {
  requestModeChange('pro');
  applyThemeByMode();
});

btnNoob?.addEventListener('click', () => {
  requestModeChange('noob');
  applyThemeByMode();
});

btnEndless?.addEventListener('click', () => {
  requestModeChange('endless');
  applyThemeByMode();
});

endlessContinue?.addEventListener('click', () => {
  closeEndlessModal();
  overlayEl.classList.remove('show');
  paused = false;
});

endlessToPro?.addEventListener('click', () => {
  closeEndlessModal();
  overlayEl.classList.remove('show');

  // ÂÖ≥Èó≠Êó†Â∞ΩÔºåÂºÄÂêØÂ§ßÁ•û
  endlessMode = false;
  endlessLocked = false;

  proMode = true;
  if(btnPro) btnPro.textContent = 'Â§ßÁ•ûÊ®°Âºè ‚úÖÔºàÊÖ¢ÊÖ¢ÂèòÂø´Ôºâ';
  if(btnEndless) btnEndless.textContent = 'Êó†Â∞ΩÊ®°Âºè ‚ôæÔ∏èÔºàÂè™Âá∫ O/IÔºâ';

  paused = false;
  stageCleared = false;
  clearingAll = false;
  reset();
  pushModeTrail();
});
stageNext?.addEventListener('click', () => {
  closeStageModal();
  overlayEl.classList.remove('show');
  paused = false;
  stageCleared = false;

  stage += 1;
  stageTarget = stageTargetFor(stage);

  // ÊØèÂÖ≥ÈáçÊñ∞ÂºÄÂßãÔºà‰Ω†Ë¶ÅÁ¥ØËÆ°ÂàÜÊï∞Â∞±Âà†ÊéâËøô3Ë°åÔºâ
  score = baseScoreForStage(stage);
  lines = 0;
  level = 1;
  updateHUD();

  board = Array.from({length:H}, () => Array(W).fill(null));
  bag = [];
  nextKind = null;
  spawn();
  draw();
});
  // ===== Mercy Mode (ÊîæÂú® IIFE ÈáåÈù¢) =====
  const btnMercy = document.getElementById('btnMercy');
  applyThemeByMode();
  const mercyModal = document.getElementById('mercyModal');
  const mercyInput = document.getElementById('mercyInput');
  const mercyTip = document.getElementById('mercyTip');
  const mercyOk = document.getElementById('mercyOk');
  const mercyCancel = document.getElementById('mercyCancel');

  function openMercy(){
    mercyModal.classList.add('show');
    mercyModal.setAttribute('aria-hidden','false');
    mercyInput.value = '';
    mercyTip.textContent = 'ËæìÂÖ•Ê≠£Á°ÆÊöóÂè∑Âêé‰ºöÁ´ãÂàªÂáèÈÄü„ÄÇ';
    mercyTip.className = 'modal-tip';
    setTimeout(()=> mercyInput.focus(), 50);
  }
  function closeMercy(){
    mercyModal.classList.remove('show');
    mercyModal.setAttribute('aria-hidden','true');
  }

  function setMercy(on){
    mercyOn = on;
    mercyMultiplier = on ? 3.5 : 1;
    btnMercy.textContent = on ? 'Ê±ÇÈ•∂‰∏≠ ‚úÖÔºàÁÇπÂèñÊ∂àÔºâ' : 'Ê±ÇÈ•∂Ê®°Âºè ü•∫';
    pushModeTrail();
    applyThemeByMode();
  }
  function tryEnableMercy(){
  const txt = (mercyInput.value || '').trim();

  if(txt === 'ÊàëÊòØËèúÈ∏°'){
    setMercy(true);

    // Â¶ÇÊûúÊòØ‰ªé‚ÄúÊ®°ÂºèÁªßÁª≠/ÈáçÂºÄ‚ÄùÊµÅÁ®ãËøõÊù•ÁöÑÔºöÊåâÁî®Êà∑ÈÄâÊã©ÊâßË°å
    if(pendingModeKey === 'mercy' && (pendingModeAction === 'restart' || pendingModeAction === 'continue')){
      const act = pendingModeAction;
      const save = pendingModeSave;

      pendingModeKey = null;
      pendingModeAction = null;
      pendingModeSave = null;

      if(act === 'continue') applyModeWithContinue('mercy', save);
      else applyModeWithRestart('mercy');
    }

    mercyTip.textContent = 'Â∑≤ÂºÄÂêØÔºÅÈÄüÂ∫¶Â∑≤ÂèòÊÖ¢ ‚úÖ';
    mercyTip.className = 'modal-tip good';
    setTimeout(closeMercy, 450);
  }else{
    mercyTip.textContent = '‰∏çÂØπÂì¶‚Ä¶ÊèêÁ§∫ÔºöÊàëÊòØËèúÈ∏°';
    mercyTip.className = 'modal-tip bad';
  }
}

btnMercy.addEventListener('click', () => {
  if(mercyOn){
    setMercy(false);
    return;
  }
  requestModeChange('mercy');
  applyThemeByMode();
});

  mercyCancel.addEventListener('click', closeMercy);
  mercyOk.addEventListener('click', tryEnableMercy);
  mercyInput.addEventListener('keydown', (e) => {
    if(e.key === 'Enter') tryEnableMercy();
  });
  mercyModal.addEventListener('click', (e) => {
    if(e.target === mercyModal) closeMercy();
  });
  // ===== Start control =====
let started = false;
const startScreen = document.getElementById('startScreen');
const btnStart = document.getElementById('btnStart');

function startGame(){
  started = true;
  startScreen?.classList.remove('show');
  showPauseButton();
  gameStartAt = Date.now();
  reset();
}

btnStart?.addEventListener('click', startGame);

// ÂÖÅËÆ∏ÈîÆÁõò Enter Áõ¥Êé•ÂºÄÂßã
window.addEventListener('keydown', (e) => {
  if(!started && (e.code === 'Enter' || e.code === 'Space')){
    e.preventDefault();
    startGame();
  }
});

// ËÆ© tick ‰∏ÄÁõ¥Ë∑ëÔºå‰ΩÜÊ≤°ÂºÄÂßãÂ∞±‰∏ç‰∏ãËêΩ
const _oldTick = tick;
tick = function(t){
  if(!started){
    requestAnimationFrame(tick);
    return;
  }
  _oldTick(t);
};

// ÂàùÂßãÔºö‰∏çËá™Âä® resetÔºå‰∏çÂºÄÂßã‰∏ãËêΩ
startScreen?.classList.add('show');
requestAnimationFrame(tick);

// ‚úÖ ÂêØÂä®Êó∂ÂÖàËØª‰∏ÄÊ¨°ÂéÜÂè≤Ôºà‰∏ãÈù¢‰ºöÊïô‰Ω†Âä† loadHistoryÔºâ
loadHistory();

// ‚úÖ BÔºöÈÄÄÂá∫/Âà∑Êñ∞‰πü‰øùÂ≠òÔºàÂè™‰øùÂ≠ò‰∏ÄÊ¨°Ôºâ
window.addEventListener('beforeunload', () => {
  if(started && !gameOver) saveRunOnce();
});

// ÂêØÂä®ÂÆåÊàêÂêéÈöêËóè splash
requestAnimationFrame(() => hideSplash());
window.addEventListener('load', hideSplash, { once:true });

})();
</script>
</body>
</html>
