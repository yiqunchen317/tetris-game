<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <meta name="theme-color" content="#0b0f17" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>ç¾¤</title>
  <style>
    html, body{
  overscroll-behavior: none;
  background-color: #0b0f17; /* é˜²æ­¢é¦–å¸§é»‘é—ª */
}
    :root{
      --cell: 28px;
      --gap: 2px;
      --bg: #0b0f17;
      --panel: #101827;
      --grid: #0f172a;
      --line: rgba(255,255,255,.06);
      --text: #e5e7eb;
      --muted:#94a3b8;
      --shadow: rgba(0,0,0,.4);
    }
    *{box-sizing:border-box}
    /* ===== Splash (Launch Screen) ===== */
.splash{
  position: fixed;
  inset: 0;
  z-index: 20000;
  display: flex;
  align-items: center;
  justify-content: center;
  background: radial-gradient(1200px 600px at 50% 0%, #152045 0%, var(--bg) 55%);
  transition: opacity .28s ease, transform .28s ease;
}
.splash.hide{
  opacity: 0;
  transform: scale(1.02);
  pointer-events: none;
}
.splash-card{
  width: min(420px, 86vw);
  text-align: center;
  padding: 18px;
  border-radius: 18px;
  background: rgba(16,24,39,.65);
  border: 1px solid rgba(255,255,255,.10);
  box-shadow: 0 18px 50px rgba(0,0,0,.45);
  backdrop-filter: blur(10px);
}
.splash-logo{
  font-weight: 950;
  letter-spacing: 2px;
  font-size: 34px;
}
.splash-sub{
  color: var(--muted);
  font-size: 13px;
}
.splash-bar{
  margin: 14px auto 0;
  width: min(280px, 72vw);
  height: 10px;
  border-radius: 999px;
  background: rgba(255,255,255,.10);
  overflow: hidden;
}
.splash-bar i{
  display:block;
  height:100%;
  width:35%;
  background: rgba(255,255,255,.25);
  animation: splashMove 1s infinite;
}
@keyframes splashMove{
  0%{transform:translateX(-10%)}
  50%{transform:translateX(180%)}
  100%{transform:translateX(-10%)}
}
    body{
      margin:0;
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      background: radial-gradient(1200px 600px at 50% 0%, #152045 0%, var(--bg) 55%);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, "PingFang SC", "Microsoft YaHei", Arial;
      padding-bottom: calc(var(--mctl-pad, 0px) + env(safe-area-inset-bottom));
      overflow-x: hidden;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
    }
    .wrap{
      display:grid;
      grid-template-columns: auto 260px;
      gap:16px;
      padding:18px;
      background: rgba(16,24,39,.55);
      border:1px solid rgba(255,255,255,.08);
      border-radius:16px;
      box-shadow: 0 18px 40px var(--shadow);
      backdrop-filter: blur(10px);
      margin-bottom: 0;
    }
    .board{
      position:relative;
      width: calc(var(--cell) * 10 + var(--gap) * 9);
      height: calc(var(--cell) * 20 + var(--gap) * 19);
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      border:1px solid rgba(255,255,255,.08);
      border-radius:12px;
      overflow:hidden;
    }
    .grid{
      position:absolute; inset:0;
      display:grid;
      grid-template-columns: repeat(10, var(--cell));
      grid-template-rows: repeat(20, var(--cell));
      gap: var(--gap);
      padding: 0;
    }
    .cell{
      width:var(--cell); height:var(--cell);
      background: rgba(15, 23, 42, .55);
      border:1px solid var(--line);
      border-radius:6px;
    }
    .cell.filled{
      border:none;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.18), rgba(255,255,255,.06));
    }
    .cell.ghost{
      background: transparent;
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.14);
      border:none;
      opacity:.55;
    }

    .side{
      display:flex;
      flex-direction:column;
      gap:12px;
      padding:10px 12px;
    }
    .card{
      background: rgba(16,24,39,.55);
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
      padding:12px;
    }
    .title{
      font-weight:800;
      letter-spacing:.5px;
      margin:0 0 6px 0;
    }
    .row{
      display:flex;
      justify-content:space-between;
      margin:6px 0;
      color:var(--muted);
      font-size:14px;
    }
    .row b{color:var(--text); font-weight:700}
    .hint{
      font-size:13px;
      color:var(--muted);
      line-height:1.45;
    }
    .btns{
      display:grid;
      grid-template-columns: repeat(2, 1fr);
      gap:10px;
      margin-top:10px;
    }
    button{
      border:none;
      border-radius:12px;
      padding:10px 12px;
      font-weight:700;
      cursor:pointer;
      background: linear-gradient(180deg, rgba(255,255,255,.14), rgba(255,255,255,.06));
      color:var(--text);
      border:1px solid rgba(255,255,255,.10);
    }
    button:active{transform: translateY(1px)}
    .overlay{
      position:absolute; inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:none;
      z-index: 5;
      font-size:28px;
      font-weight:900;
      letter-spacing:1px;
      text-shadow: 0 10px 30px rgba(0,0,0,.6);
      background: rgba(2,6,23,.35);
      opacity:0;
      transition: .15s;
    }
    .overlay.show{opacity:1}
    @media (max-width: 860px){
      .wrap{grid-template-columns: 1fr; width:min(520px, 92vw)}
      .side{flex-direction:row; flex-wrap:wrap}
      .side .card{flex:1 1 220px}
      :root{--cell: 24px}
    }

    /* ===== Mobile touch controls ===== */
    .mctl{
      position: fixed;
      left: 50%;
      bottom: 14px;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      padding: 10px;
      border-radius: 16px;
      background: rgba(2,6,23,.35);
      border: 1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(10px);
      z-index: 9999;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      touch-action: manipulation;
    }
    .mbtn{
      min-width: 52px;
      height: 48px;
      border-radius: 14px;
      font-weight: 800;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.10);
      color: var(--text);
      box-shadow: 0 10px 25px rgba(0,0,0,.25);
      padding: 0 14px;
    }
    .mbtn.wide{ min-width: 92px; }
    .mbtn:active{ transform: scale(.96); }

    @media (max-width: 520px){
      .mbtn{ min-width: 56px; height: 52px; font-size: 16px; }
      .mbtn.wide{ min-width: 104px; }
    }
    /* ===== Fix mobile alignment ===== */
    @media (max-width: 600px) {
  /* Make the board as large as the phone width/height allows */
  :root{
    /* Fit by width */
    --cellW: calc((100vw - 28px - var(--gap) * 9) / 10);
    /* Fit by height: viewport height minus safe areas and reserved controls space */
    --cellH: calc((100svh - env(safe-area-inset-top) - 14px - var(--mctl-pad, 0px) - env(safe-area-inset-bottom) - var(--gap) * 19) / 20);
    /* Choose the smaller one so the whole board fits */
    --cell: clamp(16px, min(var(--cellW), var(--cellH)), 30px);
  }

  body {
    justify-content: flex-start;
    align-items: flex-start;
    padding: calc(10px + env(safe-area-inset-top)) 0 calc(var(--mctl-pad, 0px) + env(safe-area-inset-bottom));
  }
/* Show the stats panel under the board on phone (keep board/control sizes the same) */
.side{
  display: flex;
  flex-direction: column;
  width: min(560px, 98vw);
  max-width: 98vw;
  padding: 0;
  gap: 10px;
  margin-top: 10px;
}

/* Only keep the first TETRIS stats card on phone */
.side .card:nth-child(2){ display:none; }

/* Make the stats card compact */
.side .card{
  padding: 10px 12px;
}
.side .row{ font-size: 13px; }
  .wrap {
    grid-template-columns: 1fr !important;
    justify-items: center;
    width: 100%;
    padding: 12px;
    gap: 10px;
    margin-bottom: 0;
  }

  .board {
    margin: 0 auto;
  }

  /* ===== Mobile controls layout (phone only) ===== */
  .mctl{
    display: grid;
    grid-template-columns: 1fr 1fr 1fr 14px 1fr 1fr;
    grid-template-rows: auto auto;
    gap: 10px;
    padding: 12px;
    width: min(560px, 98vw);
    max-width: 98vw;
    justify-items: center;
    align-items: center;
    touch-action: none;
    bottom: 10px;
  }

  .mctl .mbtn[data-act="left"]{ grid-column: 1; grid-row: 1; }
  .mctl .mbtn[data-act="right"]{ grid-column: 3; grid-row: 1; }
  .mctl .mbtn[data-act="down"]{ grid-column: 2; grid-row: 2; }

  .mctl .mbtn[data-act="rotate"]{ grid-column: 5; grid-row: 1; }
  .mctl .mbtn.wide[data-act="drop"]{ grid-column: 6; grid-row: 1; }

  .mctl .mbtn[data-act="pause"]{ display: none; }
    /* back to the original (smaller) touch button size */
    .mbtn{ min-width: 52px; height: 48px; font-size: 16px; }
  .mbtn.wide{ min-width: 92px; }
}
/* ===== Mercy Modal ===== */
.modal{
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(2,6,23,.55);
  z-index: 10000;
  padding: 18px;
}
.modal.show{ display: flex; }

.modal-card{
  width: min(520px, 92vw);
  background: rgba(16,24,39,.92);
  border: 1px solid rgba(255,255,255,.10);
  border-radius: 16px;
  padding: 14px;
  box-shadow: 0 18px 50px rgba(0,0,0,.45);
  backdrop-filter: blur(10px);
}

.modal-title{
  font-weight: 900;
  font-size: 18px;
  margin-bottom: 6px;
}
.modal-desc{
  color: var(--muted);
  font-size: 13px;
  line-height: 1.45;
  margin-bottom: 10px;
}

.modal-input{
  width: 100%;
  height: 44px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.08);
  color: var(--text);
  padding: 0 12px;
  outline: none;
}
.modal-input:focus{
  border-color: rgba(255,255,255,.22);
  background: rgba(255,255,255,.10);
}

.modal-tip{
  margin-top: 8px;
  font-size: 12px;
  color: var(--muted);
}
.modal-tip.bad{ color: #fca5a5; }
.modal-tip.good{ color: #86efac; }

.modal-actions{
  display: flex;
  gap: 10px;
  justify-content: flex-end;
  margin-top: 12px;
}
.modal-btn{
  border-radius: 12px;
  padding: 10px 12px;
  font-weight: 800;
}
.modal-btn.ghost{
  background: rgba(255,255,255,.06);
}
/* ===== Summary Modal ===== */
.summary{
  margin-top: 8px;
}
.summary .row{
  margin: 8px 0;
  font-size: 14px;
}
.summary small{
  display:block;
  margin-top: 8px;
  color: var(--muted);
  font-size: 12px;
  line-height: 1.4;
}
/* ===== Game Over Toast ===== */
.toast{
  position: fixed;
  left: 50%;
  top: 18%;
  transform: translateX(-50%);
  font-weight: 900;
  font-size: 34px;
  letter-spacing: 2px;
  color: rgba(255,255,255,.95);
  text-shadow: 0 12px 35px rgba(0,0,0,.6);
  opacity: 0;
  pointer-events: none;
  z-index: 15000; /* æ¯”å¼¹çª—ä½ä¹Ÿè¡Œï¼Œä½†è¦æ¯”æ¸¸æˆé«˜ */
}

.toast.show{
  animation: toastFlash 1.2s ease-out forwards;
}

@keyframes toastFlash{
  0%   { opacity: 0; transform: translateX(-50%) scale(.98); filter: blur(1px); }
  15%  { opacity: 1; transform: translateX(-50%) scale(1.03); filter: blur(0px); }
  55%  { opacity: .9; }
  100% { opacity: 0; transform: translateX(-50%) scale(1.00); filter: blur(2px); }
}
/* ===== Start Screen ===== */
.start{
  position:absolute;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  background: rgba(2,6,23,.55);
  z-index: 6; /* æ¯” overlay é«˜ä¸€ç‚¹ */
}
.start.show{ display:flex; }

.start-card{
  width: min(360px, 84%);
  padding: 16px;
  border-radius: 16px;
  background: rgba(16,24,39,.92);
  border: 1px solid rgba(255,255,255,.10);
  text-align: center;
  box-shadow: 0 18px 50px rgba(0,0,0,.45);
}
.start-title{
  font-size: 26px;
  font-weight: 900;
  letter-spacing: 2px;
}
.start-sub{
  margin-top: 6px;
  color: var(--muted);
  font-size: 13px;
}
.start-btn{
  margin-top: 12px;
  width: 100%;
  height: 46px;
  border-radius: 14px;
  font-weight: 900;
}
.start-tip{
  margin-top: 10px;
  font-size: 12px;
  color: var(--muted);
}
/* ===== Line clear particles ===== */
.particle{
  position: absolute;
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: rgba(255,255,255,.85);
  pointer-events: none;
  animation: particleFly .45s ease-out forwards;
}

@keyframes particleFly{
  from{
    transform: translate(0,0) scale(1);
    opacity: 1;
  }
  to{
    transform: translate(var(--dx), var(--dy)) scale(.2);
    opacity: 0;
  }
}
/* ===== Line clear animation ===== */
/* ===== Line clear animation ===== */
.cell.clearing{
  animation: shatter .28s cubic-bezier(.2,.8,.2,1) forwards;
  transform-origin: center;
}

@keyframes shatter{
  0%   { transform: scale(1);    opacity: 1;   filter: brightness(1); }
  20%  { transform: scale(1.22); opacity: 1;   filter: brightness(2.2); }
  60%  { transform: scale(.9);   opacity: .45; filter: brightness(1.2) blur(1px); }
  100% { transform: scale(.55);  opacity: 0;   filter: brightness(.8) blur(2px); }
}
/* ===== Faded HUD inside board ===== */
.hud{
  position: absolute;
  left: 14px;
  top: 14px;
  z-index: 4;
  pointer-events: none;
  opacity: .35;
  text-shadow: 0 10px 30px rgba(0,0,0,.55);
}

.hud-row{
  display:flex;
  align-items: baseline;
  gap: 10px;
  font-size: 16px;
  color: rgba(229,231,235,.75);
  margin: 6px 0;
}

.hud-row b{
  font-size: 22px;
  font-weight: 900;
  color: rgba(229,231,235,.95);
}

@media (max-width: 520px){
  .hud-row{ font-size: 15px; }
  .hud-row b{ font-size: 20px; }
}
/* ===== History Modal ===== */
.his-wrap{
    display: grid;
    grid-template-columns: 1fr;
    gap: 10px;
  }
  .his-top{
    display:flex;
    align-items:center;
    justify-content: space-between;
    gap: 10px;
  }
  .his-count{
    color: var(--muted);
    font-size: 12px;
  }
  .his-list{
    max-height: min(52vh, 420px);
    overflow: auto;
    -webkit-overflow-scrolling: touch;
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,.10);
    background: rgba(255,255,255,.04);
  }
  .his-item{
    width: 100%;
    text-align: left;
    display:flex;
    align-items:center;
    justify-content: space-between;
    gap: 10px;
    padding: 10px 12px;
    border: 0;
    background: transparent;
    color: var(--text);
    font-weight: 800;
    border-bottom: 1px solid rgba(255,255,255,.08);
  }
  .his-item:last-child{ border-bottom: 0; }
  .his-item small{
    display:block;
    font-weight: 700;
    color: var(--muted);
    margin-top: 2px;
  }
  .his-item:active{ transform: translateY(1px); }
  .his-detail{
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,.10);
    background: rgba(255,255,255,.04);
    padding: 10px 12px;
  }
  .his-detail .row{ font-size: 14px; }
  .his-actions{
    display:flex;
    gap: 10px;
    justify-content: flex-end;
    flex-wrap: wrap;
  }
  
  @media (min-width: 680px){
    .his-wrap{ grid-template-columns: 1fr 1fr; }
    .his-list{ max-height: min(58vh, 520px); }
  }
  </style>
  
</head>

<body>
  <!-- Splash / Launch Screen -->
<div id="splash" class="splash">
  <div class="splash-card">
    <div class="splash-logo">TETRIS</div>
    <div class="splash-sub">æ­£åœ¨åŠ è½½â€¦</div>
    <div class="splash-bar"><i></i></div>
  </div>
</div>
  <div class="wrap">
    <div class="board">
      <div id="grid" class="grid" aria-label="tetris grid"></div>
      <div id="overlay" class="overlay">PAUSED</div>
      <!-- Faded HUD inside the board -->
<div class="hud" aria-hidden="true">
  <div class="hud-row"><span>Score</span><b id="hudScore">0</b></div>
  <div class="hud-row"><span>Level</span><b id="hudLevel">1</b></div>
  <div class="hud-row"><span>Lines</span><b id="hudLines">0</b></div>
  <div class="hud-row"><span>Stage</span><b id="hudStage">1</b></div>
</div>
      <!-- Start Screen -->
  <div id="startScreen" class="start show">
    <div class="start-card">
      <div class="start-title">TETRIS</div>
      <div class="start-sub">ç‚¹å‡»å¼€å§‹æ¸¸æˆ</div>
      <button id="btnStart" class="start-btn">å¼€å§‹æ¸¸æˆ â–¶</button>
      <div class="start-tip">é”®ç›˜ / æ‰‹æœºæŒ‰é”®éƒ½æ”¯æŒ</div>
    </div>
  </div>
    </div>

    <div class="side">
      <div class="card">
        <p class="title">TETRIS</p>
        <div class="row"><span>Score</span><b id="score">0</b></div>
        <div class="row"><span>Level</span><b id="level">1</b></div>
        <div class="row"><span>Lines</span><b id="lines">0</b></div>
        <div class="row"><span>Stage</span><b id="stage">1</b></div>
        <div class="btns">
          <button id="btnPause">Pause (P)</button>
          <button id="btnReset">Reset (R)</button>
          <button id="btnNormal">æ™®é€šæ¨¡å¼ ğŸ™‚</button>
          <button id="btnMercy">æ±‚é¥¶æ¨¡å¼ ğŸ¥º</button>
          <button id="btnPro">å¤§ç¥æ¨¡å¼ âš¡ï¼ˆæ…¢æ…¢å˜å¿«ï¼‰</button>
          <button id="btnNoob">èœé¸¡æ¨¡å¼ ğŸ£ï¼ˆæ‚¬ç©ºè‡ªåŠ¨è½ï¼‰</button>
          <button id="btnEndless">æ— å°½æ¨¡å¼ â™¾ï¸ï¼ˆçˆ½æ­»ä½ ï¼‰</button>
          <button id="btnHistory">å†å²è®°å½• ğŸ—‚ï¸</button>
        </div>
        <p class="hint" style="margin-top:10px">
          é”®ç›˜ï¼šâ† â†’ ç§»åŠ¨ï¼Œâ†‘ æ—‹è½¬ï¼Œâ†“ è½¯é™ï¼ŒSpace ç¡¬é™<br/>
          P æš‚åœï¼ŒR é‡å¼€
          ï¼ˆæ‰‹æœºä¸€æ ·çš„æ“ä½œï¼Œç›¸åŒæŒ‰é’®ï¼‰666
        </p>
      </div>

      <div class="card">
        <p class="title">Tips</p>
        <p class="hint" style="margin:0">
          ä½ ç¾¤å“¥è€—è´¹ä¸€å‘¨ç²¾å¿ƒæ‰“é€ ï¼Œæœ‰å•¥ä¸ä¼šçš„æ¥é—®æˆ‘<br/>
          å•Šå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆã€‚
        </p>
      </div>
    </div>
  </div>

  <!-- Mobile Controls (touch) -->
  <div id="mobileControls" class="mctl" aria-label="mobile controls">
    <button class="mbtn" data-act="left">â¬…</button>
    <button class="mbtn" data-act="right">â¡</button>
    <button class="mbtn" data-act="rotate">ğŸ”„</button>
    <button class="mbtn" data-act="down">â¬‡</button>
    <button class="mbtn wide" data-act="drop">DROP</button>
    <button class="mbtn" data-act="pause">â¸</button>
  </div>
  <!-- Mercy modal -->
<div id="mercyModal" class="modal" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="mercyTitle">
      <div class="modal-title" id="mercyTitle">æ±‚é¥¶æ¨¡å¼ ğŸ¥º</div>
  
      <div class="modal-desc">
        è¯·è¾“å…¥æš—å·å¼€å¯æ…¢é€Ÿæ¨¡å¼ï¼ˆæç¤ºï¼šæˆ‘æ˜¯èœé¸¡ï¼‰
      </div>
  
      <input
        id="mercyInput"
        class="modal-input"
        type="text"
        inputmode="text"
        autocomplete="on"
        placeholder="ä¾‹å¦‚ï¼šæˆ‘æ˜¯èœé¸¡"
        list="mercyHints"
      />
      <datalist id="mercyHints">
        <option value="æˆ‘æ˜¯èœé¸¡"></option>
        <option value="æˆ‘æ˜¯æ–°æ‰‹"></option>
        <option value="åˆ«æ‰“æˆ‘"></option>
      </datalist>
  
      <div id="mercyTip" class="modal-tip">è¾“å…¥æ­£ç¡®æš—å·åä¼šç«‹åˆ»å‡é€Ÿã€‚</div>
  
      <div class="modal-actions">
        <button id="mercyCancel" class="modal-btn ghost">å–æ¶ˆ</button>
        <button id="mercyOk" class="modal-btn">ç¡®è®¤</button>
      </div>
    </div>
  </div>
  <div id="toast" class="toast"></div>
  <!-- Stage clear modal -->
<div id="stageModal" class="modal" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="stageTitle">
      <div class="modal-title" id="stageTitle">é€šå…³ âœ…</div>
      <div id="stageDesc" class="modal-desc">ä½ å·²é€šè¿‡æœ¬å…³ï¼</div>
      <div class="modal-actions">
        <button id="stageNext" class="modal-btn">è¿›å…¥ä¸‹ä¸€å…³ â–¶</button>
      </div>
    </div>
  </div>
  <!-- Endless modal -->
<div id="endlessModal" class="modal" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="endlessTitle">
      <div class="modal-title" id="endlessTitle">æç¤º ğŸ˜ˆ</div>
      <div id="endlessDesc" class="modal-desc">å†ç©å°±æ›´èœäº†</div>
      <div class="modal-actions">
        <button id="endlessContinue" class="modal-btn ghost">ç»§ç»­ç©</button>
        <button id="endlessToPro" class="modal-btn">æŒ‘æˆ˜å¤§ç¥æ¨¡å¼ âš¡</button>
      </div>
    </div>
  </div>
<!-- Game Summary modal -->
<div id="summaryModal" class="modal" aria-hidden="true">
  <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="summaryTitle">
    <div class="modal-title" id="summaryTitle">æœ¬å±€æ€»ç»“ ğŸ“Š</div>
    <div id="summaryBody" class="modal-desc" style="margin-bottom:12px"></div>
    <div class="modal-actions">
      <button id="summaryClose" class="modal-btn ghost">å…³é—­</button>
      <button id="summaryContinue" class="modal-btn ghost">ç»§ç»­æ¸¸æˆ â–¶</button>
      <button id="summaryRestart" class="modal-btn">å†æ¥ä¸€å±€ â–¶</button>
    </div>
  </div>
</div>
<!-- History modal -->
<div id="historyModal" class="modal" aria-hidden="true">
  <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="historyTitle">
    <div class="modal-title" id="historyTitle">å†å²è®°å½• ğŸ—‚ï¸</div>
    <div class="modal-desc" style="margin-bottom:12px">æ¯ä¸€æŠŠéƒ½ä¼šè‡ªåŠ¨ä¿å­˜åˆ°æœ¬åœ°ï¼ˆlocalStorageï¼‰ã€‚æŒ‰æ—¶é—´æ’åºï¼Œç‚¹ä¸€æ¡å¯ä»¥æŸ¥çœ‹è¯¦æƒ…ã€‚</div>

    <div class="his-wrap">
      <div>
        <div class="his-top">
          <div id="historyCount" class="his-count">0 æ¡</div>
          <button id="historyClear" class="modal-btn ghost">æ¸…ç©º</button>
        </div>
        <div id="historyList" class="his-list" aria-label="history list"></div>
      </div>

      <div>
        <div class="his-detail" aria-label="history detail">
          <div id="historyDetail" class="modal-desc" style="margin:0">ç‚¹å·¦è¾¹ä¸€æ¡è®°å½•æŸ¥çœ‹ã€‚</div>
        </div>
      </div>
    </div>

    <div class="his-actions" style="margin-top:12px">
      <button id="historyClose" class="modal-btn ghost">å…³é—­</button>
    </div>
  </div>
</div>
<!-- Clear History Confirm modal -->
<div id="clearHistoryModal" class="modal" aria-hidden="true">
  <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="clearHistoryTitle">
    <div class="modal-title" id="clearHistoryTitle">æç¤º ğŸ˜ˆ</div>
    <div class="modal-desc" id="clearHistoryDesc">ä½ æ˜¯ä¸æ˜¯ç©ä¸èµ·</div>

    <div class="modal-actions">
      <button id="clearHistoryCancel" class="modal-btn ghost">æˆ‘ç‚¹é”™äº†</button>
      <button id="clearHistoryOk" class="modal-btn">æ˜¯çš„</button>
    </div>
  </div>
</div>
<!-- Mode Resume modal -->
<div id="modeResumeModal" class="modal" aria-hidden="true">
  <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="modeResumeTitle">
    <div class="modal-title" id="modeResumeTitle">æ¨¡å¼è¿›åº¦</div>
    <div id="modeResumeBody" class="modal-desc" style="margin-bottom:12px"></div>

    <div class="modal-actions">
      <button id="modeResumeCancel" class="modal-btn ghost">å–æ¶ˆ</button>
      <button id="modeResumeRestart" class="modal-btn ghost">ä»ç¬¬ 1 å…³é‡æ–°å¼€å§‹</button>
      <button id="modeResumeContinue" class="modal-btn">ç»§ç»­å½“å‰ç­‰çº§ â–¶</button>
    </div>
  </div>
</div>
<script>
(() => {
    // ===== Splash control =====
    const splashEl = document.getElementById('splash');
  const splashStart = Date.now();
  function hideSplash(){
    if(!splashEl) return;
    const wait = Math.max(0, 800 - (Date.now() - splashStart));
    setTimeout(() => {
      splashEl.classList.add('hide');
      setTimeout(() => splashEl.remove(), 320);
    }, wait);
  }
  const W = 10, H = 20;

  // 0 empty, 1 filled
  let board = Array.from({length:H}, () => Array(W).fill(0));

  const gridEl = document.getElementById('grid');
  const overlayEl = document.getElementById('overlay');
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const linesEl = document.getElementById('lines');
  const stageEl = document.getElementById('stage');
  const hudScoreEl = document.getElementById('hudScore');
const hudLevelEl = document.getElementById('hudLevel');
const hudLinesEl = document.getElementById('hudLines');
const hudStageEl = document.getElementById('hudStage');
  const btnPro = document.getElementById('btnPro');
  const btnNoob = document.getElementById('btnNoob');
  const btnEndless = document.getElementById('btnEndless');
  const btnNormal = document.getElementById('btnNormal');

const endlessModal = document.getElementById('endlessModal');
const endlessDesc = document.getElementById('endlessDesc');
const endlessContinue = document.getElementById('endlessContinue');
const endlessToPro = document.getElementById('endlessToPro');
const summaryModal = document.getElementById('summaryModal');
const summaryBody  = document.getElementById('summaryBody');
const summaryClose = document.getElementById('summaryClose');
const summaryContinue = document.getElementById('summaryContinue');
const summaryRestart = document.getElementById('summaryRestart');
  const stageModal = document.getElementById('stageModal');
  const stageDesc = document.getElementById('stageDesc');
  const stageNext = document.getElementById('stageNext');
  document.getElementById('btnPause').onclick = () => togglePause();
  document.getElementById('btnReset').onclick = () => {
  if(!started) startGame();
  else {
    // âœ… å…ˆæŠŠè¿™ä¸€æŠŠå­˜èµ·æ¥ï¼ˆåªä¼šå­˜ä¸€æ¬¡ï¼‰
    if(!gameOver) saveRunOnce();
    reset();
  }
};

  // build cells once
  const cells = [];
  for(let i=0;i<W*H;i++){
    const d = document.createElement('div');
    d.className = 'cell';
    gridEl.appendChild(d);
    cells.push(d);
  }

  const SHAPES = {
    I: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
    O: [[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],
    T: [[0,1,0,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],
    S: [[0,1,1,0],[1,1,0,0],[0,0,0,0],[0,0,0,0]],
    Z: [[1,1,0,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],
    J: [[1,0,0,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],
    L: [[0,0,1,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],
  };
  const ORDER = ["I","O","T","S","Z","J","L"];

  const rotCW = m => m[0].map((_,i) => m.map(r=>r[i]).reverse());
  const cellsOf = m => {
    const out = [];
    for(let y=0;y<4;y++) for(let x=0;x<4;x++) if(m[y][x]) out.push([y,x]);
    return out;
  };
  const rotations = {};
  for(const k of ORDER){
    let m = SHAPES[k];
    const rots = [];
    const seen = new Set();
    for(let i=0;i<4;i++){
      const c = JSON.stringify(cellsOf(m));
      if(!seen.has(c)){ seen.add(c); rots.push(cellsOf(m)); }
      m = rotCW(m);
    }
    rotations[k] = rots;
  }

  // 7-bag random
  let bag = [];
  const refillBag = () => {
  const pool = endlessMode ? ["I","O"] : ORDER;
  bag = pool.slice().sort(() => Math.random() - 0.5);
};

  let piece, nextKind;
  let score=0, lines=0, level=1;
  let paused=false, gameOver=false;
  let gameOverPendingSave = false; // GAME OVER å¼¹æ€»ç»“ï¼Œä½†è¿˜æ²¡å†™å†å²ï¼ˆç»™â€œç»§ç»­æ¸¸æˆâ€ç•™æœºä¼šï¼‰
  // ===== Stats for summary =====
let piecesLocked = 0;
let hardDrops = 0;
let softDrops = 0;
let gameStartAt = 0;
  let stage = 1;
let stageTarget = 500;
let proMode = false;        // å¤§ç¥æ¨¡å¼ï¼šç”¨ä½ åŸæ¥çš„ level é€Ÿåº¦æœºåˆ¶
let stageCleared = false;   // é€šå…³åç­‰å¾…è¿›ä¸‹ä¸€å…³
let clearingAll = false;    // é€šå…³æ—¶å…¨åœºæ‘§æ¯åŠ¨ç”»
let noobMode = false; // èœé¸¡æ¨¡å¼ï¼šæ¶ˆè¡Œåæ‚¬ç©ºæ–¹å—è‡ªåŠ¨è½ä¸‹
let endlessMode = false;   // æ— å°½æ¨¡å¼ï¼šåªå‡º O/I
let endlessLocked = false; // åˆ° 2000 åˆ†ååªå¼¹ä¸€æ¬¡
  let mercyOn = false;
let mercyMultiplier = 1; // 1=æ­£å¸¸ï¼Œ>1 è¶Šå¤§è¶Šæ…¢
let clearing = false;
let clearingRows = new Set(); // è®°å½•æ­£åœ¨æ¶ˆé™¤çš„è¡Œ
  // ===== Toast helper =====
  const toastEl = document.getElementById('toast');
  function showToast(msg){
    if(!toastEl) return;
    toastEl.textContent = msg;
    toastEl.classList.remove('show');
    // å¼ºåˆ¶é‡å¯åŠ¨ç”»
    void toastEl.offsetWidth;
    toastEl.classList.add('show');
  }
  const lineScore = {1:100,2:300,3:500,4:800};
  function openStageModal(){
  if(!stageModal) return;
  stageModal.classList.add('show');
  stageModal.setAttribute('aria-hidden','false');
}
function closeStageModal(){
  if(!stageModal) return;
  stageModal.classList.remove('show');
  stageModal.setAttribute('aria-hidden','true');
}

function winStage(){
  if(stageCleared || proMode) return;
  stageCleared = true;
  clearingAll = true;

  draw(); // è®©å…¨åœºæ–¹å—å¼€å§‹æ’­æ”¾ clearing åŠ¨ç”»

  setTimeout(() => {
    board = Array.from({length:H}, () => Array(W).fill(0));
    clearingAll = false;

    paused = true;
    overlayEl.textContent = "STAGE CLEAR";
    overlayEl.classList.add('show');

    stageTarget = stageTargetFor(stage);
    if(stageDesc) stageDesc.textContent = `ç¬¬ ${stage} å…³é€šå…³ï¼ç›®æ ‡ ${stageTarget} åˆ†å·²è¾¾æˆã€‚ç‚¹å‡»è¿›å…¥ä¸‹ä¸€å…³ã€‚`;
    saveRunOnce(); // âœ… Cï¼šé€šå…³ä¹Ÿå­˜ä¸€æŠŠ
    openStageModal();
    draw();
  }, 280);
}

function checkStage(){
  if(proMode) return;
  if(stageCleared) return;
  if(endlessMode) return;
  stageTarget = stageTargetFor(stage);
  if(score >= stageTarget){
    winStage();
  }
}
function openEndlessModal(){
  if(!endlessModal) return;
  endlessModal.classList.add('show');
  endlessModal.setAttribute('aria-hidden','false');
}
function closeEndlessModal(){
  if(!endlessModal) return;
  endlessModal.classList.remove('show');
  endlessModal.setAttribute('aria-hidden','true');
}
function openSummaryModal(){
  if(!summaryModal) return;
  renderSummary();
  summaryModal.classList.add('show');
  summaryModal.setAttribute('aria-hidden','false');
}
function closeSummaryModal(){
  if(!summaryModal) return;
  summaryModal.classList.remove('show');
  summaryModal.setAttribute('aria-hidden','true');
}
function continueAfterGameOver(){
  if(!gameOver) return;

  // ç»§ç»­ï¼šä¸é‡å¼€ï¼Œä¸æ¸…åˆ†æ•°/å…³å¡/ç­‰çº§
  gameOver = false;
  gameOverPendingSave = false;
  savedThisGame = false; // å…è®¸åé¢æ­£å¸¸å­˜ä¸€æ¬¡

  paused = false;
  stageCleared = false;
  clearingAll = false;
  clearing = false;
  clearingRows = new Set();

  overlayEl.classList.remove('show');
  overlayEl.textContent = "";

  closeSummaryModal();

  // ä¸ºäº†èƒ½ç»§ç»­ï¼šæ¸…æ‰é¡¶éƒ¨ 8 è¡Œï¼Œç­‰äºâ€œæ’¤å›æœ€å 8 ä¸ªæ“ä½œâ€ï¼Œä¿è¯èƒ½ç”Ÿæˆæ–°æ–¹å—
for(let y=0; y<8; y++){
  for(let x=0; x<W; x++) board[y][x] = 0;
}

  // å°è¯•ç”Ÿæˆï¼›å¦‚æœè¿˜æ”¾ä¸ä¸‹å°±ç›´æ¥æ¸…ç©ºæ£‹ç›˜ç»§ç»­
  spawn();
  if(gameOver){
    gameOver = false;
    board = Array.from({length:H}, () => Array(W).fill(0));
    bag = [];
    nextKind = null;
    spawn();
  }

  draw();
}

function fmtTime(ms){
  const s = Math.max(0, Math.floor(ms/1000));
  const mm = String(Math.floor(s/60)).padStart(2,'0');
  const ss = String(s%60).padStart(2,'0');
  return `${mm}:${ss}`;
}

function modeLabel(){
  const m = [];
  if(proMode) m.push('å¤§ç¥');
  if(noobMode) m.push('èœé¸¡');
  if(endlessMode) m.push('æ— å°½');
  if(mercyOn) m.push('æ±‚é¥¶');
  return m.length ? m.join(' / ') : 'æ™®é€š';
}
// ===== Per-mode progress (localStorage) =====
const MODE_SAVE_KEY = 'tetris_mode_progress_v1';

function modeKeyFromFlags(){
  if(proMode) return 'pro';
  if(noobMode) return 'noob';
  if(endlessMode) return 'endless';
  if(mercyOn) return 'mercy';
  return 'normal';
}

function modeLabelFromKey(k){
  if(k === 'pro') return 'å¤§ç¥';
  if(k === 'noob') return 'èœé¸¡';
  if(k === 'endless') return 'æ— å°½';
  if(k === 'mercy') return 'æ±‚é¥¶';
  return 'æ™®é€š';
}

function loadModeProgressAll(){
  try{
    const raw = localStorage.getItem(MODE_SAVE_KEY);
    const obj = raw ? JSON.parse(raw) : {};
    return (obj && typeof obj === 'object') ? obj : {};
  }catch(e){
    return {};
  }
}

function saveModeProgressAll(all){
  try{ localStorage.setItem(MODE_SAVE_KEY, JSON.stringify(all)); }catch(e){}
}

function saveCurrentModeProgress(){
  const key = modeKeyFromFlags();
  const all = loadModeProgressAll();

  const cur = {
    stage: stage ?? 1,
    level: level ?? 1,
    score: score ?? 0,
    lines: lines ?? 0,
    ts: Date.now(),
  };

  const prev = all[key];
  if(!prev){
    all[key] = cur;
    saveModeProgressAll(all);
    return;
  }

  const prevStage = prev.stage ?? 1;
  const prevLevel = prev.level ?? 1;
  const prevScore = prev.score ?? 0;
  const prevLines = prev.lines ?? 0;

  // è§„åˆ™ï¼š
  // 1) å…³å¡æ›´é«˜ -> ç›´æ¥ç”¨å½“å‰è®°å½•
  // 2) åŒå…³å¡ä½†ç­‰çº§æ›´é«˜ -> ç›´æ¥ç”¨å½“å‰è®°å½•
  // 3) åŒå…³åŒçº§ -> åˆ†æ•°/æ¶ˆè¡Œå–æ›´é«˜ï¼ˆä¿æŒæœ€é«˜è®°å½•ï¼‰
  if(cur.stage > prevStage || (cur.stage === prevStage && cur.level > prevLevel)){
    all[key] = cur;
  }else if(cur.stage === prevStage && cur.level === prevLevel){
    all[key] = {
      stage: prevStage,
      level: prevLevel,
      score: Math.max(prevScore, cur.score),
      lines: Math.max(prevLines, cur.lines),
      ts: Date.now(),
    };
  } // å…³å¡/ç­‰çº§æ›´ä½ï¼šå¿½ç•¥ï¼Œä¸è¦†ç›–æœ€é«˜è®°å½•

  saveModeProgressAll(all);
}

function fmtDateShort(ts){
  try{ return new Date(ts).toLocaleString('zh-CN', { hour12:false }); }
  catch(e){ return ''; }
}

// åªé‡ç½®æ£‹ç›˜/è¢‹å­/å½“å‰å—ï¼Œä¸åŠ¨ stage/level/score/lines
function resetBoardOnly(){
  board = Array.from({length:H}, () => Array(W).fill(0));

  piecesLocked = 0;
  hardDrops = 0;
  softDrops = 0;
  gameStartAt = Date.now();
  savedThisGame = false;
  resetModeTrail();

  paused = false;
  gameOver = false;
  stageCleared = false;
  clearingAll = false;
  clearing = false;
  clearingRows = new Set();

  closeSummaryModal();
  closeStageModal();
  closeEndlessModal?.();

  overlayEl.classList.remove('show');
  overlayEl.textContent = "PAUSED";

  bag = [];
  nextKind = null;
  updateHUD();
  spawn();
  draw();
}

// ===== Mode resume modal elements =====
const modeResumeModal = document.getElementById('modeResumeModal');
const modeResumeTitle = document.getElementById('modeResumeTitle');
const modeResumeBody  = document.getElementById('modeResumeBody');
const modeResumeCancel = document.getElementById('modeResumeCancel');
const modeResumeRestart = document.getElementById('modeResumeRestart');
const modeResumeContinue = document.getElementById('modeResumeContinue');

let pendingModeKey = null;
let pendingModeAction = null; // 'restart' | 'continue'
let pendingModeSave = null;

function openModeResumeModal(){
  if(!modeResumeModal) return;
  modeResumeModal.classList.add('show');
  modeResumeModal.setAttribute('aria-hidden','false');
}

function closeModeResumeModal(){
  if(!modeResumeModal) return;
  modeResumeModal.classList.remove('show');
  modeResumeModal.setAttribute('aria-hidden','true');
}

function setFlagsByModeKey(k){
  // å…ˆå…³æ‰€æœ‰æ¨¡å¼ï¼ˆåŒ…æ‹¬æ±‚é¥¶ï¼‰
  turnOffAllModes();

  if(k === 'pro'){
    proMode = true;
    if(btnPro) btnPro.textContent = 'å¤§ç¥æ¨¡å¼ âœ…ï¼ˆæ…¢æ…¢å˜å¿«ï¼‰';
  }else if(k === 'noob'){
    noobMode = true;
    if(btnNoob) btnNoob.textContent = 'èœé¸¡æ¨¡å¼ âœ…ï¼ˆæ‚¬ç©ºè‡ªåŠ¨è½ï¼‰';
  }else if(k === 'endless'){
    endlessMode = true;
    endlessLocked = false;
    if(btnEndless) btnEndless.textContent = 'æ— å°½æ¨¡å¼ âœ…ï¼ˆåªå‡º O/Iï¼‰';
  }else if(k === 'normal'){
    // æ™®é€šï¼šå…¨éƒ¨å…³é—­å°±è¡Œ
  }else if(k === 'mercy'){
    // æ±‚é¥¶ï¼šä¸ç›´æ¥å¼€ï¼Œç­‰ç©å®¶è¾“æš—å·æˆåŠŸå setMercy(true)
  }

  try{ pushModeTrail?.(); }catch(e){}
}

function applyModeWithRestart(k){
  setFlagsByModeKey(k);
  started = true;
  startScreen?.classList.remove('show');
  reset();
}

function applyModeWithContinue(k, save){
  setFlagsByModeKey(k);

  if(save){
    stage = save.stage ?? 1;
    level = save.level ?? 1;
    score = save.score ?? 0;
    lines = save.lines ?? 0;
  }

  started = true;
  startScreen?.classList.remove('show');
  resetBoardOnly();
}

function requestModeChange(k){
  // åˆ‡æ¨¡å¼å‰ï¼ŒæŠŠå½“å‰è¿™æŠŠå…ˆå­˜ä¸€ä¸‹ï¼ˆé¿å…ä¸¢è¿›åº¦ï¼‰
  if(started && !gameOver) saveRunOnce();

  const all = loadModeProgressAll();
  const save = all[k];

  // æ²¡å­˜æ¡£ï¼šç›´æ¥å½“â€œé‡å¼€â€
  if(!save){
    if(k === 'mercy'){
      pendingModeKey = 'mercy';
      pendingModeAction = 'restart';
      pendingModeSave = null;
      setFlagsByModeKey('mercy');
      openMercy();
      return;
    }
    applyModeWithRestart(k);
    return;
  }

  // æœ‰å­˜æ¡£ï¼šå¼¹çª—è®©ç©å®¶é€‰
  pendingModeKey = k;
  pendingModeSave = save;

  if(modeResumeTitle) modeResumeTitle.textContent = `${modeLabelFromKey(k)} æ¨¡å¼è¿›åº¦`;
  if(modeResumeBody){
    modeResumeBody.innerHTML = `
      <div class="summary">
      <div class="row"><span>è®°å½•æ—¶é—´</span><b>${save.ts ? fmtDateShort(save.ts) : '-'}</b></div>
<div class="row"><span>å†å²æœ€é«˜å…³å¡</span><b>${save.stage ?? 1}</b></div>
<div class="row"><span>å†å²æœ€é«˜ç­‰çº§</span><b>${save.level ?? 1}</b></div>
<div class="row"><span>å†å²æœ€é«˜åˆ†</span><b>${save.score ?? 0}</b></div>
<div class="row"><span>å†å²æœ€é«˜æ¶ˆè¡Œ</span><b>${save.lines ?? 0}</b></div>
<small>â€œç»§ç»­â€ä¼šä»è¯¥æ¨¡å¼ã€å†å²æœ€é«˜ã€‘è¿›åº¦ç»§ç»­ï¼›â€œé‡æ–°å¼€å§‹â€ä»ç¬¬ 1 å…³é‡æ–°æ¥ã€‚</small>  
      </div>
    `;
  }

  openModeResumeModal();
}
// ===== Mode trail (track mode switches within a run) =====
let modeTrail = [];

function resetModeTrail(){
  // æœ¬å±€èµ·ç‚¹ï¼šå½“å‰æ¨¡å¼
  modeTrail = [modeLabel()];
}

function pushModeTrail(){
  const cur = modeLabel();
  const last = modeTrail.length ? modeTrail[modeTrail.length - 1] : null;
  if(cur && cur !== last) modeTrail.push(cur);
}
// ===== History (localStorage) =====
const btnHistory = document.getElementById('btnHistory'); // æ²¡æœ‰æŒ‰é’®ä¹Ÿä¸å½±å“ï¼ˆå¯é€‰ï¼‰
const historyModal = document.getElementById('historyModal');
const historyList = document.getElementById('historyList');
const historyDetail = document.getElementById('historyDetail');
const historyClose = document.getElementById('historyClose');
const historyClear = document.getElementById('historyClear');
const historyCount = document.getElementById('historyCount');
const clearHistoryModal = document.getElementById('clearHistoryModal');
const clearHistoryCancel = document.getElementById('clearHistoryCancel');
const clearHistoryOk = document.getElementById('clearHistoryOk');

const LS_KEY = 'tetris_runs_v1';
let savedThisGame = false;
let historyCache = [];

function loadHistory(){
  try{
    const raw = localStorage.getItem(LS_KEY);
    const arr = raw ? JSON.parse(raw) : [];
    historyCache = Array.isArray(arr) ? arr : [];
  }catch(e){
    historyCache = [];
  }
  historyCache.sort((a,b) => (b.ts||0) - (a.ts||0)); // æœ€æ–°åœ¨å‰
}

function saveHistory(){
  try{ localStorage.setItem(LS_KEY, JSON.stringify(historyCache)); }catch(e){}
}

function fmtDate(ts){
  try{ return new Date(ts).toLocaleString('zh-CN', { hour12:false }); }
  catch(e){ return String(ts); }
}

function snapshotRun(){
  const dur = gameStartAt ? (Date.now() - gameStartAt) : 0;
  return {
    id: String(Date.now()) + '-' + Math.random().toString(16).slice(2),
    ts: Date.now(),
    score, lines, stage, level,
    piecesLocked, hardDrops, softDrops,
    durationMs: dur,
    mode: modeLabel(),
    modeTrail: Array.isArray(modeTrail) ? modeTrail.slice() : [modeLabel()],
  };
}

function saveRunOnce(){
  if(savedThisGame) return;
  if(!Array.isArray(modeTrail) || modeTrail.length === 0) resetModeTrail();
pushModeTrail();
  savedThisGame = true;
  loadHistory();
  historyCache.unshift(snapshotRun());
  if(historyCache.length > 200) historyCache.length = 200;
  saveHistory();
saveCurrentModeProgress();
}

function renderHistoryDetail(run){
  if(!historyDetail) return;
  if(!run){
    historyDetail.innerHTML = 'ç‚¹å·¦è¾¹ä¸€æ¡è®°å½•æŸ¥çœ‹ã€‚';
    return;
  }
  historyDetail.innerHTML = `
    <div class="summary">
      <div class="row"><span>æ—¶é—´</span><b>${fmtDate(run.ts)}</b></div>
      <div class="row"><span>å¾—åˆ†</span><b>${run.score ?? 0}</b></div>
      <div class="row"><span>æ¶ˆè¡Œ</span><b>${run.lines ?? 0}</b></div>
      <div class="row"><span>å…³å¡</span><b>${run.stage ?? 1}</b></div>
      <div class="row"><span>ç­‰çº§</span><b>${run.level ?? 1}</b></div>
      <div class="row"><span>è½å—æ•°</span><b>${run.piecesLocked ?? 0}</b></div>
      <div class="row"><span>ç¡¬é™æ¬¡æ•°</span><b>${run.hardDrops ?? 0}</b></div>
      <div class="row"><span>è½¯é™æ¬¡æ•°</span><b>${run.softDrops ?? 0}</b></div>
      <div class="row"><span>ç”¨æ—¶</span><b>${fmtTime(run.durationMs ?? 0)}</b></div>
    <div class="row"><span>æ¨¡å¼</span><b>${(Array.isArray(run.modeTrail) && run.modeTrail.length ? run.modeTrail.join(' â†’ ') : (run.mode ?? 'æ™®é€š'))}</b></div>
    </div>
  `;
}

function renderHistoryList(){
  if(!historyList) return;
  if(historyCount) historyCount.textContent = `${historyCache.length} æ¡`;

  if(historyCache.length === 0){
    historyList.innerHTML = `<div class="modal-desc" style="padding:10px 12px; margin:0">æš‚æ— è®°å½•ï¼Œå…ˆç©ä¸€æŠŠã€‚</div>`;
    renderHistoryDetail(null);
    return;
  }

  historyList.innerHTML = historyCache.map((run) => {
    return `
      <button class="his-item" data-hid="${run.id}">
        <div>
          ${fmtDate(run.ts)}
          <small>Score ${run.score ?? 0} Â· Lines ${run.lines ?? 0} Â· ${run.mode ?? 'æ™®é€š'}</small>
        </div>
        <div>â€º</div>
      </button>
    `;
  }).join('');

  renderHistoryDetail(historyCache[0]);

  historyList.querySelectorAll('button[data-hid]').forEach(btn => {
    btn.addEventListener('click', () => {
      const id = btn.getAttribute('data-hid');
      const run = historyCache.find(r => r.id === id);
      renderHistoryDetail(run);
    });
  });
}

function openHistoryModal(){
  if(!historyModal) return;
  loadHistory();
  renderHistoryList();
  historyModal.classList.add('show');
  historyModal.setAttribute('aria-hidden','false');
}

function closeHistoryModal(){
  if(!historyModal) return;
  historyModal.classList.remove('show');
  historyModal.setAttribute('aria-hidden','true');
}
function openClearHistoryModal(){
  if(!clearHistoryModal) return;
  clearHistoryModal.classList.add('show');
  clearHistoryModal.setAttribute('aria-hidden','false');
}
function closeClearHistoryModal(){
  if(!clearHistoryModal) return;
  clearHistoryModal.classList.remove('show');
  clearHistoryModal.setAttribute('aria-hidden','true');
}
function renderSummary(){
  if(!summaryBody) return;
  const dur = gameStartAt ? (Date.now() - gameStartAt) : 0;

  summaryBody.innerHTML = `
    <div class="summary">
      <div class="row"><span>å¾—åˆ†</span><b>${score}</b></div>
      <div class="row"><span>æ¶ˆè¡Œ</span><b>${lines}</b></div>
      <div class="row"><span>å…³å¡</span><b>${stage}</b></div>
      <div class="row"><span>ç­‰çº§</span><b>${level}</b></div>
      <div class="row"><span>è½å—æ•°</span><b>${piecesLocked}</b></div>
      <div class="row"><span>ç¡¬é™æ¬¡æ•°</span><b>${hardDrops}</b></div>
      <div class="row"><span>è½¯é™æ¬¡æ•°</span><b>${softDrops}</b></div>
      <div class="row"><span>ç”¨æ—¶</span><b>${fmtTime(dur)}</b></div>
      <div class="row"><span>æ¨¡å¼</span><b>${modeLabel()}</b></div>
      <small>æç¤ºï¼šæƒ³æ›´å¼ºï¼Ÿèœå°±å¤šç»ƒ ğŸ˜ˆ</small>
    </div>
  `;
}

// summary buttons
summaryClose?.addEventListener('click', () => {
  // å¦‚æœæ˜¯ GAME OVER è§¦å‘çš„æ€»ç»“ï¼šæ­¤æ—¶æ‰ç®—ä¸€å±€ç»“æŸï¼Œå†™å…¥å†å²
  if(gameOverPendingSave){
    saveRunOnce();
    gameOverPendingSave = false;
  }
  closeSummaryModal();
});

summaryContinue?.addEventListener('click', () => {
  // ç»§ç»­æ¸¸æˆï¼šä¸å†™å†å²ï¼Œä¸é‡å¼€
  continueAfterGameOver();
});

summaryRestart?.addEventListener('click', () => {
  // å¦‚æœæ˜¯ GAME OVER è§¦å‘çš„æ€»ç»“ï¼šæ­¤æ—¶æ‰ç®—ä¸€å±€ç»“æŸï¼Œå†™å…¥å†å²
  if(gameOverPendingSave){
    saveRunOnce();
    gameOverPendingSave = false;
  }

  closeSummaryModal();
  if(!started){
    startGame();
  }else{
    reset();
    paused = false;
    overlayEl.classList.remove('show');
  }
});

// ç‚¹å‡»é®ç½©å…³é—­
summaryModal?.addEventListener('click', (e) => {
  if(e.target === summaryModal) closeSummaryModal();
});
btnHistory?.addEventListener('click', () => openHistoryModal());
historyClose?.addEventListener('click', () => closeHistoryModal());
historyModal?.addEventListener('click', (e) => {
  if(e.target === historyModal) closeHistoryModal();
});
historyClear?.addEventListener('click', () => {
  openClearHistoryModal();
});
clearHistoryCancel?.addEventListener('click', () => {
  closeClearHistoryModal();
});

clearHistoryOk?.addEventListener('click', () => {
  historyCache = [];
  saveHistory();
  renderHistoryList();
  closeClearHistoryModal();
});

// ç‚¹é®ç½©å…³é—­
clearHistoryModal?.addEventListener('click', (e) => {
  if(e.target === clearHistoryModal) closeClearHistoryModal();
});
// ===== Mode Resume modal events =====
modeResumeCancel?.addEventListener('click', () => {
  pendingModeKey = null;
  pendingModeSave = null;
  closeModeResumeModal();
});

modeResumeModal?.addEventListener('click', (e) => {
  if(e.target === modeResumeModal){
    pendingModeKey = null;
    pendingModeSave = null;
    closeModeResumeModal();
  }
});

modeResumeRestart?.addEventListener('click', () => {
  const k = pendingModeKey;
  const save = pendingModeSave;
  pendingModeKey = null;
  pendingModeSave = null;
  closeModeResumeModal();

  if(!k) return;

  if(k === 'mercy'){
    pendingModeKey = 'mercy';
    pendingModeAction = 'restart';
    pendingModeSave = save;
    setFlagsByModeKey('mercy');
    openMercy();
    return;
  }

  applyModeWithRestart(k);
});

modeResumeContinue?.addEventListener('click', () => {
  const k = pendingModeKey;
  const save = pendingModeSave;
  pendingModeKey = null;
  pendingModeSave = null;
  closeModeResumeModal();

  if(!k) return;

  if(k === 'mercy'){
    pendingModeKey = 'mercy';
    pendingModeAction = 'continue';
    pendingModeSave = save;
    setFlagsByModeKey('mercy');
    openMercy();
    return;
  }

  applyModeWithContinue(k, save);
});

function checkEndlessCap(){
  if(!endlessMode) return;
  if(endlessLocked) return;
  if(score >= 1000){
    endlessLocked = true;
    paused = true;
    overlayEl.textContent = "1000+";
    overlayEl.classList.add('show');
    if(endlessDesc) endlessDesc.textContent = "å†ç©å°±æ›´èœäº†";
    openEndlessModal();
  }
}
  function spawn(){
    if(bag.length === 0) refillBag();
    const kind = nextKind ?? bag.pop();
    if(bag.length === 0) refillBag();
    nextKind = bag.pop();

    piece = { kind, r:0, x:3, y:0 };
    if(!canPlace(piece, 0, 0, 0)) {
      gameOver = true;
      overlayEl.textContent = "GAME OVER (R)";
      overlayEl.classList.add('show');
      showToast("èœå°±å¤šç»ƒ");
setTimeout(() => {
  if(gameOver){
    gameOverPendingSave = true;
    openSummaryModal();
  }
}, 1350);
    }
  }

  function canPlace(p, dx, dy, dr){
    const rots = rotations[p.kind];
    const nr = (p.r + dr + rots.length) % rots.length;
    for(const [cy,cx] of rots[nr]){
      const x = p.x + dx + cx;
      const y = p.y + dy + cy;
      if(x<0 || x>=W || y<0 || y>=H) return false;
      if(board[y][x]) return false;
    }
    return true;
  }

  function lock(){
    piecesLocked++;
  for(const [cy,cx] of rotations[piece.kind][piece.r]){
    board[piece.y+cy][piece.x+cx] = 1;
  }
  const didClear = clearLines();
  if(!didClear) spawn(); // æ²¡æ¶ˆé™¤æ‰ç«‹åˆ»å‡ºä¸‹ä¸€å—
}
// ç²’å­çˆ†æ•£æ•ˆæœ
function spawnParticlesForRow(rowY){
  const boardEl = document.querySelector('.board');
  if(!boardEl) return;

  const rect = boardEl.getBoundingClientRect();
  const cellSize = rect.width / 10;

  for(let x = 0; x < 10; x++){
    for(let i = 0; i < 4; i++){
      const p = document.createElement('div');
      p.className = 'particle';

      const px = x * cellSize + cellSize / 2;
      const py = rowY * cellSize + cellSize / 2;

      const dx = (Math.random() - 0.5) * 120;
      const dy = -Math.random() * 160;

      p.style.left = px + 'px';
      p.style.top  = py + 'px';
      p.style.setProperty('--dx', dx + 'px');
      p.style.setProperty('--dy', dy + 'px');

      boardEl.appendChild(p);
      setTimeout(() => p.remove(), 500);
    }
  }
}

  function clearLines(){
  // æ‰¾å‡ºæ»¡è¡Œ
  const full = [];
  for(let y=0;y<H;y++){
    let ok = true;
    for(let x=0;x<W;x++){
      if(!board[y][x]) { ok = false; break; }
    }
    if(ok) full.push(y);
  }

  if(full.length === 0) return false;

  // è¿›å…¥æ¶ˆé™¤åŠ¨ç”»çŠ¶æ€
  clearing = true;
  clearingRows = new Set(full);

  // æ’­æ”¾åŠ¨ç”»ä¸€å°æ®µæ—¶é—´åï¼Œå†çœŸæ­£åˆ é™¤è¡Œ
  setTimeout(() => {
    // ç²’å­çˆ†æ•£æ•ˆæœ
for(const y of clearingRows){
  spawnParticlesForRow(y);
}
    // åˆ é™¤æ»¡è¡Œ
    board = board.filter((_, y) => !clearingRows.has(y));
    while(board.length < H) board.unshift(Array(W).fill(0));
    if(noobMode){
  applyNoobGravity();
}

    // è®¡åˆ†/å‡çº§
    const cleared = full.length;
    lines += cleared;
    score += (lineScore[cleared] || 0) * level;
    if(proMode) level = 1 + Math.floor(lines/2);
    updateHUD();
    checkStage();

    // é€€å‡ºæ¶ˆé™¤çŠ¶æ€
    clearing = false;
    clearingRows = new Set();

    // ç»§ç»­ç”Ÿæˆä¸‹ä¸€å—ï¼ˆé‡è¦ï¼šè¿™é‡Œå† spawnï¼‰
    spawn();
  }, 280); // å’Œ CSS åŠ¨ç”»æ—¶é—´åŒ¹é…ï¼ˆ.28sï¼‰

  return true;
}
function applyNoobGravity(){
  // æ¯ä¸€åˆ—æŠŠæ–¹å—â€œå‹å®â€åˆ°æœ€åº•ä¸‹ï¼ˆåƒæ²™å­ä¸€æ ·ç›´è½ï¼‰
  for(let x=0; x<W; x++){
    let writeY = H - 1;
    for(let y = H - 1; y >= 0; y--){
      if(board[y][x]){
        if(y !== writeY){
          board[writeY][x] = 1;
          board[y][x] = 0;
        }
        writeY--;
      }
    }
  }
}
  function ghostY(){
    let y = piece.y;
    while(canPlace(piece, 0, (y-piece.y)+1, 0)) y++;
    return y;
  }

  function hardDrop(){
    hardDrops++;
    const gy = ghostY();
    score += Math.max(0, gy - piece.y) * 2;
    piece.y = gy;
    updateHUD();
checkStage();
checkEndlessCap();
lock();
  }

  function stageTargetFor(s){
  return 500 + (s-1)*300;
}
function stageIntervalFor(s){
  // æ¯å…³å›ºå®šä¸€ä¸ªé€Ÿåº¦ï¼ˆè¶Šå¾€åè¶Šå¿«ï¼‰ï¼Œæƒ³æ›´å¿«/æ›´æ…¢å°±æ”¹è¿™é‡Œ
  return Math.max(0.12, 0.60 - (s-1)*0.05);
}

function updateHUD(){
  scoreEl.textContent = score;
  levelEl.textContent = level;
  linesEl.textContent = lines;
  if(stageEl) stageEl.textContent = stage;

  if(hudScoreEl) hudScoreEl.textContent = score;
  if(hudLevelEl) hudLevelEl.textContent = level;
  if(hudLinesEl) hudLinesEl.textContent = lines;
  if(hudStageEl) hudStageEl.textContent = stage;
}

  function draw(){
    // reset all
    for(const c of cells){ c.className = 'cell'; }

    // settled
    // settled
for(let y=0;y<H;y++){
  for(let x=0;x<W;x++){
    if(board[y][x]){
      const idx = y*W+x;
      cells[idx].classList.add('filled');
      if(clearingAll || clearingRows.has(y)) cells[idx].classList.add('clearing');
    }
  }
}

    if(!gameOver){
      // ghost
      const gy = ghostY();
      for(const [cy,cx] of rotations[piece.kind][piece.r]){
        const y = gy+cy, x = piece.x+cx;
        const idx = y*W+x;
        if(!board[y][x]) cells[idx].classList.add('ghost');
      }
      // active
      for(const [cy,cx] of rotations[piece.kind][piece.r]){
        const y = piece.y+cy, x = piece.x+cx;
        cells[y*W+x].classList.add('filled');
      }
    }
  }

  function togglePause(){
    if(gameOver) return;
    paused = !paused;
    overlayEl.textContent = paused ? "PAUSED" : "";
    overlayEl.classList.toggle('show', paused);
  }

  function reset(){
    board = Array.from({length:H}, () => Array(W).fill(0));
    score=0; lines=0; level=1;
    piecesLocked = 0;
hardDrops = 0;
softDrops = 0;
gameStartAt = Date.now();
closeSummaryModal();
savedThisGame = false;
resetModeTrail();
gameOverPendingSave = false;
    paused=false; gameOver=false;
    stageCleared = false;
  clearingAll = false;
  closeStageModal();
    overlayEl.classList.remove('show');
    overlayEl.textContent = "PAUSED";
    bag = [];
    nextKind = null;
    updateHUD();
    spawn();
  }

  // main loop
  let last = performance.now();
  let acc = 0;
  function tick(t){
    const dt = (t-last)/1000;
    last = t;

    if(!paused && !gameOver){
  if(!clearing){
    acc += dt;
    const baseInterval = proMode
  ? Math.max(0.08, 0.4 - (level-1)*0.015)   // ä½ åŸæ¥çš„æœºåˆ¶
  : stageIntervalFor(stage);                 // å…³å¡å›ºå®šé€Ÿåº¦

const interval = baseInterval * mercyMultiplier;
    if(acc >= interval){
      acc = 0;
      if(canPlace(piece,0,1,0)) piece.y += 1;
      else lock();
    }
  }
  draw(); // âœ… ä¸ç®¡ clearing ä¸å¦éƒ½ç”»ï¼Œè¿™æ ·åŠ¨ç”»ä¸€ç›´æ’­æ”¾
}
    requestAnimationFrame(tick);
  }

  // controls (keyboard + mobile)
  function tryRotate(dr){
  if(!piece) return false;

  // ç®€åŒ–ç‰ˆ wall-kickï¼šåŸåœ°è½¬ä¸äº†å°±å°è¯•æŒªä¸€ä¸‹å†è½¬
  const kicks = [
    [0,0],
    [-1,0],[1,0],
    [-2,0],[2,0],
    [0,-1],
    [-1,-1],[1,-1]
  ];

  for(const [kx,ky] of kicks){
    if(canPlace(piece, kx, ky, dr)){
      const rots = rotations[piece.kind];
      piece.r = (piece.r + dr + rots.length) % rots.length;
      piece.x += kx;
      piece.y += ky;
      return true;
    }
  }
  return false;
}
  function handleControl(code){
    if(code === 'KeyP'){ togglePause(); return; }
    if(code === 'KeyR'){
  // é”®ç›˜ R é‡å¼€ä¹Ÿç®—ä¸€å±€ç»“æŸï¼Œå…ˆå­˜ä¸€æ¬¡
  if(started && !gameOver) saveRunOnce();
  reset();
  return;
}
    if(code === 'KeyQ'){ return; }
    if(!started || paused || gameOver || stageCleared) return;

    if(code === 'ArrowLeft'){
      if(canPlace(piece,-1,0,0)) piece.x -= 1;
    } else if(code === 'ArrowRight'){
      if(canPlace(piece, 1,0,0)) piece.x += 1;
    } else if(code === 'ArrowDown'){
        if(canPlace(piece,0,1,0)) { piece.y += 1; score += 1; softDrops++; updateHUD(); checkStage(); checkEndlessCap(); }
      else lock();
    } else if(code === 'ArrowUp'){
  tryRotate(1);

} else if(code === 'KeyZ'){
  tryRotate(-1);
} else if(code === 'Space'){
  hardDrop();
}
    draw();
  }

  window.addEventListener('keydown', (e) => {
    // é˜²æ­¢æ‰‹æœºå¤–æ¥é”®ç›˜/ç”µè„‘æµè§ˆå™¨æŒ‰ç©ºæ ¼æ»šåŠ¨
    if(e.code === 'Space') e.preventDefault();
    handleControl(e.code);
  });

  // ===== Mobile buttons =====
  const mctl = document.getElementById('mobileControls');
  let repeatTimer = null;
// ===== Auto reserve space for mobile controls (no guessing) =====
function updateBottomSpace(){
  const m = document.getElementById('mobileControls');
  if(!m) return;

  const rect = m.getBoundingClientRect();
  const style = getComputedStyle(m);

  // mctl è‡ªå·±çš„é«˜åº¦ + å®ƒç¦»åº•éƒ¨çš„è·ç¦» + ä¸€ç‚¹ç‚¹å®‰å…¨è¾¹è·
  const bottom = parseFloat(style.bottom || '0') || 0;
  const gap = 12; // ä½ æƒ³æ›´ç´§å°± 8ï¼Œæ›´æ¾å°± 16

  const pad = Math.ceil(rect.height + bottom + gap);
  document.documentElement.style.setProperty('--mctl-pad', pad + 'px');
}

// é¡µé¢åŠ è½½ã€çª—å£å˜åŒ–ã€æ—‹è½¬éƒ½æ›´æ–°
updateBottomSpace();
window.addEventListener('resize', updateBottomSpace);
window.addEventListener('orientationchange', updateBottomSpace);
  function startRepeat(code, ms){
    stopRepeat();
    handleControl(code); // å…ˆè§¦å‘ä¸€æ¬¡
    repeatTimer = setInterval(() => handleControl(code), ms);
  }
  function stopRepeat(){
    if(repeatTimer){ clearInterval(repeatTimer); repeatTimer = null; }
  }

  if(mctl){
    const actToCode = (act) => {
      if(act === 'left') return 'ArrowLeft';
      if(act === 'right') return 'ArrowRight';
      if(act === 'down') return 'ArrowDown';
      if(act === 'rotate') return 'ArrowUp';
      if(act === 'drop') return 'Space';
      if(act === 'pause') return 'KeyP';
      return null;
    };

    // é˜²æ­¢è§¦æ§æ»‘åŠ¨é¡µé¢
    mctl.addEventListener('touchmove', (e) => e.preventDefault(), {passive:false});

    mctl.querySelectorAll('button[data-act]').forEach(btn => {
      const act = btn.dataset.act;
      const code = actToCode(act);

      const onDown = (e) => {
        e.preventDefault();
        if(!code) return;

        // å·¦/å³/ä¸‹ï¼šé•¿æŒ‰è¿å‘
        if(code === 'ArrowLeft' || code === 'ArrowRight') startRepeat(code, 90);
        else if(code === 'ArrowDown') startRepeat(code, 60);
        else handleControl(code); // æ—‹è½¬/ç¡¬é™/æš‚åœï¼šç‚¹ä¸€ä¸‹å³å¯
      };

      const onUp = (e) => {
        e.preventDefault();
        stopRepeat();
      };

      btn.addEventListener('touchstart', onDown, {passive:false});
      btn.addEventListener('touchend', onUp, {passive:false});
      btn.addEventListener('touchcancel', onUp, {passive:false});

      // ç”µè„‘ä¸Šä¹Ÿèƒ½ç‚¹
      btn.addEventListener('mousedown', onDown);
      btn.addEventListener('mouseup', onUp);
      btn.addEventListener('mouseleave', onUp);
      btn.addEventListener('click', (e) => e.preventDefault());
    });
  }
  // block double-tap zoom (iOS)
let lastTouchEnd = 0;
document.addEventListener('touchend', (e) => {
  const now = Date.now();
  if(now - lastTouchEnd <= 300) e.preventDefault();
  lastTouchEnd = now;
}, { passive: false });
function turnOffAllModes(){
  // å…³æ±‚é¥¶
  if(mercyOn) setMercy(false);

  // å…³å…¶ä»–æ¨¡å¼
  proMode = false;
  noobMode = false;
  endlessMode = false;
  endlessLocked = false;
  closeEndlessModal?.();
  overlayEl.classList.remove('show');
  overlayEl.textContent = "";

  // è¿˜åŸæŒ‰é’®æ–‡å­—ï¼ˆæŒ‰ä½ ç°åœ¨çš„æ–‡æ¡ˆå†™ï¼‰
  if(btnPro) btnPro.textContent = 'å¤§ç¥æ¨¡å¼ âš¡ï¼ˆæ…¢æ…¢å˜å¿«ï¼‰';
  if(btnNoob) btnNoob.textContent = 'èœé¸¡æ¨¡å¼ ğŸ£ï¼ˆæ‚¬ç©ºè‡ªåŠ¨è½ï¼‰';
  if(btnEndless) btnEndless.textContent = 'æ— å°½æ¨¡å¼ â™¾ï¸ï¼ˆçˆ½æ­»ä½ ï¼‰';
}
btnNormal?.addEventListener('click', () => {
  requestModeChange('normal');
});
btnPro?.addEventListener('click', () => {
  requestModeChange('pro');
});

btnNoob?.addEventListener('click', () => {
  requestModeChange('noob');
});

btnEndless?.addEventListener('click', () => {
  requestModeChange('endless');
});

endlessContinue?.addEventListener('click', () => {
  closeEndlessModal();
  overlayEl.classList.remove('show');
  paused = false;
});

endlessToPro?.addEventListener('click', () => {
  closeEndlessModal();
  overlayEl.classList.remove('show');

  // å…³é—­æ— å°½ï¼Œå¼€å¯å¤§ç¥
  endlessMode = false;
  endlessLocked = false;

  proMode = true;
  if(btnPro) btnPro.textContent = 'å¤§ç¥æ¨¡å¼ âœ…ï¼ˆæ…¢æ…¢å˜å¿«ï¼‰';
  if(btnEndless) btnEndless.textContent = 'æ— å°½æ¨¡å¼ â™¾ï¸ï¼ˆåªå‡º O/Iï¼‰';

  paused = false;
  stageCleared = false;
  clearingAll = false;
  reset();
  pushModeTrail();
});
stageNext?.addEventListener('click', () => {
  closeStageModal();
  overlayEl.classList.remove('show');
  paused = false;
  stageCleared = false;

  stage += 1;
  stageTarget = stageTargetFor(stage);

  // æ¯å…³é‡æ–°å¼€å§‹ï¼ˆä½ è¦ç´¯è®¡åˆ†æ•°å°±åˆ æ‰è¿™3è¡Œï¼‰
  score = 0;
  lines = 0;
  level = 1;
  updateHUD();

  board = Array.from({length:H}, () => Array(W).fill(0));
  bag = [];
  nextKind = null;
  spawn();
  draw();
});
  // ===== Mercy Mode (æ”¾åœ¨ IIFE é‡Œé¢) =====
  const btnMercy = document.getElementById('btnMercy');
  const mercyModal = document.getElementById('mercyModal');
  const mercyInput = document.getElementById('mercyInput');
  const mercyTip = document.getElementById('mercyTip');
  const mercyOk = document.getElementById('mercyOk');
  const mercyCancel = document.getElementById('mercyCancel');

  function openMercy(){
    mercyModal.classList.add('show');
    mercyModal.setAttribute('aria-hidden','false');
    mercyInput.value = '';
    mercyTip.textContent = 'è¾“å…¥æ­£ç¡®æš—å·åä¼šç«‹åˆ»å‡é€Ÿã€‚';
    mercyTip.className = 'modal-tip';
    setTimeout(()=> mercyInput.focus(), 50);
  }
  function closeMercy(){
    mercyModal.classList.remove('show');
    mercyModal.setAttribute('aria-hidden','true');
  }

  function setMercy(on){
    mercyOn = on;
    mercyMultiplier = on ? 3.5 : 1;
    btnMercy.textContent = on ? 'æ±‚é¥¶ä¸­ âœ…ï¼ˆç‚¹å–æ¶ˆï¼‰' : 'æ±‚é¥¶æ¨¡å¼ ğŸ¥º';
    pushModeTrail();
  }
  function tryEnableMercy(){
  const txt = (mercyInput.value || '').trim();

  if(txt === 'æˆ‘æ˜¯èœé¸¡'){
    setMercy(true);

    // å¦‚æœæ˜¯ä»â€œæ¨¡å¼ç»§ç»­/é‡å¼€â€æµç¨‹è¿›æ¥çš„ï¼šæŒ‰ç”¨æˆ·é€‰æ‹©æ‰§è¡Œ
    if(pendingModeKey === 'mercy' && (pendingModeAction === 'restart' || pendingModeAction === 'continue')){
      const act = pendingModeAction;
      const save = pendingModeSave;

      pendingModeKey = null;
      pendingModeAction = null;
      pendingModeSave = null;

      if(act === 'continue') applyModeWithContinue('mercy', save);
      else applyModeWithRestart('mercy');
    }

    mercyTip.textContent = 'å·²å¼€å¯ï¼é€Ÿåº¦å·²å˜æ…¢ âœ…';
    mercyTip.className = 'modal-tip good';
    setTimeout(closeMercy, 450);
  }else{
    mercyTip.textContent = 'ä¸å¯¹å“¦â€¦æç¤ºï¼šæˆ‘æ˜¯èœé¸¡';
    mercyTip.className = 'modal-tip bad';
  }
}

  btnMercy.addEventListener('click', () => {
  if(mercyOn){
    setMercy(false);
    return;
  }
  requestModeChange('mercy');
});

  mercyCancel.addEventListener('click', closeMercy);
  mercyOk.addEventListener('click', tryEnableMercy);
  mercyInput.addEventListener('keydown', (e) => {
    if(e.key === 'Enter') tryEnableMercy();
  });
  mercyModal.addEventListener('click', (e) => {
    if(e.target === mercyModal) closeMercy();
  });
  // ===== Start control =====
let started = false;
const startScreen = document.getElementById('startScreen');
const btnStart = document.getElementById('btnStart');

function startGame(){
  started = true;
  startScreen?.classList.remove('show');
  gameStartAt = Date.now();
  reset();
}

btnStart?.addEventListener('click', startGame);

// å…è®¸é”®ç›˜ Enter ç›´æ¥å¼€å§‹
window.addEventListener('keydown', (e) => {
  if(!started && (e.code === 'Enter' || e.code === 'Space')){
    e.preventDefault();
    startGame();
  }
});

// è®© tick ä¸€ç›´è·‘ï¼Œä½†æ²¡å¼€å§‹å°±ä¸ä¸‹è½
const _oldTick = tick;
tick = function(t){
  if(!started){
    requestAnimationFrame(tick);
    return;
  }
  _oldTick(t);
};

// åˆå§‹ï¼šä¸è‡ªåŠ¨ resetï¼Œä¸å¼€å§‹ä¸‹è½
startScreen?.classList.add('show');
requestAnimationFrame(tick);

// âœ… å¯åŠ¨æ—¶å…ˆè¯»ä¸€æ¬¡å†å²ï¼ˆä¸‹é¢ä¼šæ•™ä½ åŠ  loadHistoryï¼‰
loadHistory();

// âœ… Bï¼šé€€å‡º/åˆ·æ–°ä¹Ÿä¿å­˜ï¼ˆåªä¿å­˜ä¸€æ¬¡ï¼‰
window.addEventListener('beforeunload', () => {
  if(started && !gameOver) saveRunOnce();
});

// å¯åŠ¨å®Œæˆåéšè— splash
requestAnimationFrame(() => hideSplash());
window.addEventListener('load', hideSplash, { once:true });

})();
</script>
</body>
</html>
