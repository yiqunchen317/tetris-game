<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Tetris - HTML/CSS/JS</title>
  <style>
    html, body{
  overscroll-behavior: none;
}
    :root{
      --cell: 28px;
      --gap: 2px;
      --bg: #0b0f17;
      --panel: #101827;
      --grid: #0f172a;
      --line: rgba(255,255,255,.06);
      --text: #e5e7eb;
      --muted:#94a3b8;
      --shadow: rgba(0,0,0,.4);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      background: radial-gradient(1200px 600px at 50% 0%, #152045 0%, var(--bg) 55%);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, "PingFang SC", "Microsoft YaHei", Arial;
      padding-bottom: calc(var(--mctl-pad, 0px) + env(safe-area-inset-bottom));
      overflow-x: hidden;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
    }
    .wrap{
      display:grid;
      grid-template-columns: auto 260px;
      gap:16px;
      padding:18px;
      background: rgba(16,24,39,.55);
      border:1px solid rgba(255,255,255,.08);
      border-radius:16px;
      box-shadow: 0 18px 40px var(--shadow);
      backdrop-filter: blur(10px);
      margin-bottom: calc(var(--mctl-pad, 0px) + env(safe-area-inset-bottom));
    }
    .board{
      position:relative;
      width: calc(var(--cell) * 10 + var(--gap) * 9);
      height: calc(var(--cell) * 20 + var(--gap) * 19);
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      border:1px solid rgba(255,255,255,.08);
      border-radius:12px;
      overflow:hidden;
    }
    .grid{
      position:absolute; inset:0;
      display:grid;
      grid-template-columns: repeat(10, var(--cell));
      grid-template-rows: repeat(20, var(--cell));
      gap: var(--gap);
      padding: 0;
    }
    .cell{
      width:var(--cell); height:var(--cell);
      background: rgba(15, 23, 42, .55);
      border:1px solid var(--line);
      border-radius:6px;
    }
    .cell.filled{
      border:none;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.18), rgba(255,255,255,.06));
    }
    .cell.ghost{
      background: transparent;
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.14);
      border:none;
      opacity:.55;
    }

    .side{
      display:flex;
      flex-direction:column;
      gap:12px;
      padding:10px 12px;
    }
    .card{
      background: rgba(16,24,39,.55);
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
      padding:12px;
    }
    .title{
      font-weight:800;
      letter-spacing:.5px;
      margin:0 0 6px 0;
    }
    .row{
      display:flex;
      justify-content:space-between;
      margin:6px 0;
      color:var(--muted);
      font-size:14px;
    }
    .row b{color:var(--text); font-weight:700}
    .hint{
      font-size:13px;
      color:var(--muted);
      line-height:1.45;
    }
    .btns{
      display:grid;
      grid-template-columns: repeat(2, 1fr);
      gap:10px;
      margin-top:10px;
    }
    button{
      border:none;
      border-radius:12px;
      padding:10px 12px;
      font-weight:700;
      cursor:pointer;
      background: linear-gradient(180deg, rgba(255,255,255,.14), rgba(255,255,255,.06));
      color:var(--text);
      border:1px solid rgba(255,255,255,.10);
    }
    button:active{transform: translateY(1px)}
    .overlay{
      position:absolute; inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:none;
      z-index: 5;
      font-size:28px;
      font-weight:900;
      letter-spacing:1px;
      text-shadow: 0 10px 30px rgba(0,0,0,.6);
      background: rgba(2,6,23,.35);
      opacity:0;
      transition: .15s;
    }
    .overlay.show{opacity:1}
    @media (max-width: 860px){
      .wrap{grid-template-columns: 1fr; width:min(520px, 92vw)}
      .side{flex-direction:row; flex-wrap:wrap}
      .side .card{flex:1 1 220px}
      :root{--cell: 24px}
    }

    /* ===== Mobile touch controls ===== */
    .mctl{
      position: fixed;
      left: 50%;
      bottom: 14px;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      padding: 10px;
      border-radius: 16px;
      background: rgba(2,6,23,.35);
      border: 1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(10px);
      z-index: 9999;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      touch-action: manipulation;
    }
    .mbtn{
      min-width: 52px;
      height: 48px;
      border-radius: 14px;
      font-weight: 800;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.10);
      color: var(--text);
      box-shadow: 0 10px 25px rgba(0,0,0,.25);
      padding: 0 14px;
    }
    .mbtn.wide{ min-width: 92px; }
    .mbtn:active{ transform: scale(.96); }

    @media (max-width: 520px){
      .mctl{ gap: 8px; padding: 9px; }
      .mbtn{ min-width: 56px; height: 52px; font-size: 16px; }
      .mbtn.wide{ min-width: 104px; }
    }
    /* ===== Fix mobile alignment ===== */
@media (max-width: 600px) {
  body {
    justify-content: flex-start;
    align-items: flex-start;
  }

  .wrap {
    grid-template-columns: 1fr !important;
    justify-items: center;
    width: 100%;
    padding: 12px;
  }

  .board {
    margin: 0 auto;
  }

  .side {
    width: 100%;
    max-width: 420px;
    margin: 12px auto 0;
  }

  .mctl {
    left: 50%;
    transform: translateX(-50%);
    bottom: 10px;
  }
}
/* ===== Mercy Modal ===== */
.modal{
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(2,6,23,.55);
  z-index: 10000;
  padding: 18px;
}
.modal.show{ display: flex; }

.modal-card{
  width: min(520px, 92vw);
  background: rgba(16,24,39,.92);
  border: 1px solid rgba(255,255,255,.10);
  border-radius: 16px;
  padding: 14px;
  box-shadow: 0 18px 50px rgba(0,0,0,.45);
  backdrop-filter: blur(10px);
}

.modal-title{
  font-weight: 900;
  font-size: 18px;
  margin-bottom: 6px;
}
.modal-desc{
  color: var(--muted);
  font-size: 13px;
  line-height: 1.45;
  margin-bottom: 10px;
}

.modal-input{
  width: 100%;
  height: 44px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.08);
  color: var(--text);
  padding: 0 12px;
  outline: none;
}
.modal-input:focus{
  border-color: rgba(255,255,255,.22);
  background: rgba(255,255,255,.10);
}

.modal-tip{
  margin-top: 8px;
  font-size: 12px;
  color: var(--muted);
}
.modal-tip.bad{ color: #fca5a5; }
.modal-tip.good{ color: #86efac; }

.modal-actions{
  display: flex;
  gap: 10px;
  justify-content: flex-end;
  margin-top: 12px;
}
.modal-btn{
  border-radius: 12px;
  padding: 10px 12px;
  font-weight: 800;
}
.modal-btn.ghost{
  background: rgba(255,255,255,.06);
}
/* ===== Game Over Toast ===== */
.toast{
  position: fixed;
  left: 50%;
  top: 18%;
  transform: translateX(-50%);
  font-weight: 900;
  font-size: 34px;
  letter-spacing: 2px;
  color: rgba(255,255,255,.95);
  text-shadow: 0 12px 35px rgba(0,0,0,.6);
  opacity: 0;
  pointer-events: none;
  z-index: 15000; /* æ¯”å¼¹çª—ä½ä¹Ÿè¡Œï¼Œä½†è¦æ¯”æ¸¸æˆé«˜ */
}

.toast.show{
  animation: toastFlash 1.2s ease-out forwards;
}

@keyframes toastFlash{
  0%   { opacity: 0; transform: translateX(-50%) scale(.98); filter: blur(1px); }
  15%  { opacity: 1; transform: translateX(-50%) scale(1.03); filter: blur(0px); }
  55%  { opacity: .9; }
  100% { opacity: 0; transform: translateX(-50%) scale(1.00); filter: blur(2px); }
}
/* ===== Start Screen ===== */
.start{
  position:absolute;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  background: rgba(2,6,23,.55);
  z-index: 6; /* æ¯” overlay é«˜ä¸€ç‚¹ */
}
.start.show{ display:flex; }

.start-card{
  width: min(360px, 84%);
  padding: 16px;
  border-radius: 16px;
  background: rgba(16,24,39,.92);
  border: 1px solid rgba(255,255,255,.10);
  text-align: center;
  box-shadow: 0 18px 50px rgba(0,0,0,.45);
}
.start-title{
  font-size: 26px;
  font-weight: 900;
  letter-spacing: 2px;
}
.start-sub{
  margin-top: 6px;
  color: var(--muted);
  font-size: 13px;
}
.start-btn{
  margin-top: 12px;
  width: 100%;
  height: 46px;
  border-radius: 14px;
  font-weight: 900;
}
.start-tip{
  margin-top: 10px;
  font-size: 12px;
  color: var(--muted);
}
  </style>
</head>

<body>
  <div class="wrap">
    <div class="board">
      <div id="grid" class="grid" aria-label="tetris grid"></div>
      <div id="overlay" class="overlay">PAUSED</div>
      <!-- Start Screen -->
  <div id="startScreen" class="start show">
    <div class="start-card">
      <div class="start-title">TETRIS</div>
      <div class="start-sub">ç‚¹å‡»å¼€å§‹æ¸¸æˆ</div>
      <button id="btnStart" class="start-btn">å¼€å§‹æ¸¸æˆ â–¶</button>
      <div class="start-tip">é”®ç›˜ / æ‰‹æœºæŒ‰é”®éƒ½æ”¯æŒ</div>
    </div>
  </div>
    </div>

    <div class="side">
      <div class="card">
        <p class="title">TETRIS</p>
        <div class="row"><span>Score</span><b id="score">0</b></div>
        <div class="row"><span>Level</span><b id="level">1</b></div>
        <div class="row"><span>Lines</span><b id="lines">0</b></div>
        <div class="btns">
          <button id="btnPause">Pause (P)</button>
          <button id="btnReset">Reset (R)</button>
          <button id="btnMercy">æ±‚é¥¶æ¨¡å¼ ğŸ¥º</button>
        </div>
        <p class="hint" style="margin-top:10px">
          é”®ç›˜ï¼šâ† â†’ ç§»åŠ¨ï¼Œâ†‘ æ—‹è½¬ï¼Œâ†“ è½¯é™ï¼ŒSpace ç¡¬é™<br/>
          P æš‚åœï¼ŒR é‡å¼€
          ï¼ˆæ‰‹æœºä¸€æ ·çš„æ“ä½œï¼Œç›¸åŒæŒ‰é’®ï¼‰666
        </p>
      </div>

      <div class="card">
        <p class="title">Tips</p>
        <p class="hint" style="margin:0">
          ä½ ç¾¤å“¥è€—è´¹ä¸€å‘¨ç²¾å¿ƒæ‰“é€ ï¼Œæœ‰å•¥ä¸ä¼šçš„æ¥é—®æˆ‘<br/>
          å•Šå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆã€‚
        </p>
      </div>
    </div>
  </div>

  <!-- Mobile Controls (touch) -->
  <div id="mobileControls" class="mctl" aria-label="mobile controls">
    <button class="mbtn" data-act="left">â¬…</button>
    <button class="mbtn" data-act="right">â¡</button>
    <button class="mbtn" data-act="rotate">ğŸ”„</button>
    <button class="mbtn" data-act="down">â¬‡</button>
    <button class="mbtn wide" data-act="drop">DROP</button>
    <button class="mbtn" data-act="pause">â¸</button>
  </div>
  <!-- Mercy modal -->
<div id="mercyModal" class="modal" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="mercyTitle">
      <div class="modal-title" id="mercyTitle">æ±‚é¥¶æ¨¡å¼ ğŸ¥º</div>
  
      <div class="modal-desc">
        è¯·è¾“å…¥æš—å·å¼€å¯æ…¢é€Ÿæ¨¡å¼ï¼ˆæç¤ºï¼šæˆ‘æ˜¯èœé¸¡ï¼‰
      </div>
  
      <input
        id="mercyInput"
        class="modal-input"
        type="text"
        inputmode="text"
        autocomplete="on"
        placeholder="ä¾‹å¦‚ï¼šæˆ‘æ˜¯èœé¸¡"
        list="mercyHints"
      />
      <datalist id="mercyHints">
        <option value="æˆ‘æ˜¯èœé¸¡"></option>
        <option value="æˆ‘æ˜¯æ–°æ‰‹"></option>
        <option value="åˆ«æ‰“æˆ‘"></option>
      </datalist>
  
      <div id="mercyTip" class="modal-tip">è¾“å…¥æ­£ç¡®æš—å·åä¼šç«‹åˆ»å‡é€Ÿã€‚</div>
  
      <div class="modal-actions">
        <button id="mercyCancel" class="modal-btn ghost">å–æ¶ˆ</button>
        <button id="mercyOk" class="modal-btn">ç¡®è®¤</button>
      </div>
    </div>
  </div>
  <div id="toast" class="toast"></div>
<script>
(() => {
  const W = 10, H = 20;

  // 0 empty, 1 filled
  let board = Array.from({length:H}, () => Array(W).fill(0));

  const gridEl = document.getElementById('grid');
  const overlayEl = document.getElementById('overlay');
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const linesEl = document.getElementById('lines');
  document.getElementById('btnPause').onclick = () => togglePause();
  document.getElementById('btnReset').onclick = () => { if(!started) startGame(); else reset(); };

  // build cells once
  const cells = [];
  for(let i=0;i<W*H;i++){
    const d = document.createElement('div');
    d.className = 'cell';
    gridEl.appendChild(d);
    cells.push(d);
  }

  const SHAPES = {
    I: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
    O: [[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],
    T: [[0,1,0,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],
    S: [[0,1,1,0],[1,1,0,0],[0,0,0,0],[0,0,0,0]],
    Z: [[1,1,0,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],
    J: [[1,0,0,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],
    L: [[0,0,1,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],
  };
  const ORDER = ["I","O","T","S","Z","J","L"];

  const rotCW = m => m[0].map((_,i) => m.map(r=>r[i]).reverse());
  const cellsOf = m => {
    const out = [];
    for(let y=0;y<4;y++) for(let x=0;x<4;x++) if(m[y][x]) out.push([y,x]);
    return out;
  };
  const rotations = {};
  for(const k of ORDER){
    let m = SHAPES[k];
    const rots = [];
    const seen = new Set();
    for(let i=0;i<4;i++){
      const c = JSON.stringify(cellsOf(m));
      if(!seen.has(c)){ seen.add(c); rots.push(cellsOf(m)); }
      m = rotCW(m);
    }
    rotations[k] = rots;
  }

  // 7-bag random
  let bag = [];
  const refillBag = () => {
    bag = ORDER.slice().sort(() => Math.random() - 0.5);
  };

  let piece, nextKind;
  let score=0, lines=0, level=1;
  let paused=false, gameOver=false;
  let mercyOn = false;
let mercyMultiplier = 1; // 1=æ­£å¸¸ï¼Œ>1 è¶Šå¤§è¶Šæ…¢
  // ===== Toast helper =====
  const toastEl = document.getElementById('toast');
  function showToast(msg){
    if(!toastEl) return;
    toastEl.textContent = msg;
    toastEl.classList.remove('show');
    // å¼ºåˆ¶é‡å¯åŠ¨ç”»
    void toastEl.offsetWidth;
    toastEl.classList.add('show');
  }
  const lineScore = {1:100,2:300,3:500,4:800};

  function spawn(){
    if(bag.length === 0) refillBag();
    const kind = nextKind ?? bag.pop();
    if(bag.length === 0) refillBag();
    nextKind = bag.pop();

    piece = { kind, r:0, x:3, y:0 };
    if(!canPlace(piece, 0, 0, 0)) {
      gameOver = true;
      overlayEl.textContent = "GAME OVER (R)";
      overlayEl.classList.add('show');
      showToast("èœå°±å¤šç»ƒ");
    }
  }

  function canPlace(p, dx, dy, dr){
    const rots = rotations[p.kind];
    const nr = (p.r + dr + rots.length) % rots.length;
    for(const [cy,cx] of rots[nr]){
      const x = p.x + dx + cx;
      const y = p.y + dy + cy;
      if(x<0 || x>=W || y<0 || y>=H) return false;
      if(board[y][x]) return false;
    }
    return true;
  }

  function lock(){
    for(const [cy,cx] of rotations[piece.kind][piece.r]){
      board[piece.y+cy][piece.x+cx] = 1;
    }
    clearLines();
    spawn();
  }

  function clearLines(){
    let cleared = 0;
    board = board.filter(row => row.some(v => v===0) ? true : (cleared++, false));
    while(board.length < H) board.unshift(Array(W).fill(0));
    if(cleared){
      lines += cleared;
      score += (lineScore[cleared] || 0) * level;
      level = 1 + Math.floor(lines/10);
      updateHUD();
    }
  }

  function ghostY(){
    let y = piece.y;
    while(canPlace(piece, 0, (y-piece.y)+1, 0)) y++;
    return y;
  }

  function hardDrop(){
    const gy = ghostY();
    score += Math.max(0, gy - piece.y) * 2;
    piece.y = gy;
    updateHUD();
    lock();
  }

  function updateHUD(){
    scoreEl.textContent = score;
    levelEl.textContent = level;
    linesEl.textContent = lines;
  }

  function draw(){
    // reset all
    for(const c of cells){ c.className = 'cell'; }

    // settled
    for(let y=0;y<H;y++){
      for(let x=0;x<W;x++){
        if(board[y][x]) cells[y*W+x].classList.add('filled');
      }
    }

    if(!gameOver){
      // ghost
      const gy = ghostY();
      for(const [cy,cx] of rotations[piece.kind][piece.r]){
        const y = gy+cy, x = piece.x+cx;
        const idx = y*W+x;
        if(!board[y][x]) cells[idx].classList.add('ghost');
      }
      // active
      for(const [cy,cx] of rotations[piece.kind][piece.r]){
        const y = piece.y+cy, x = piece.x+cx;
        cells[y*W+x].classList.add('filled');
      }
    }
  }

  function togglePause(){
    if(gameOver) return;
    paused = !paused;
    overlayEl.textContent = paused ? "PAUSED" : "";
    overlayEl.classList.toggle('show', paused);
  }

  function reset(){
    board = Array.from({length:H}, () => Array(W).fill(0));
    score=0; lines=0; level=1;
    paused=false; gameOver=false;
    overlayEl.classList.remove('show');
    overlayEl.textContent = "PAUSED";
    bag = [];
    nextKind = null;
    updateHUD();
    spawn();
  }

  // main loop
  let last = performance.now();
  let acc = 0;
  function tick(t){
    const dt = (t-last)/1000;
    last = t;

    if(!paused && !gameOver){
      acc += dt;
      const baseInterval = Math.max(0.08, 0.55 - (level-1)*0.045);
const interval = baseInterval * mercyMultiplier;
      if(acc >= interval){
        acc = 0;
        if(canPlace(piece,0,1,0)) piece.y += 1;
        else lock();
      }
      draw();
    }
    requestAnimationFrame(tick);
  }

  // controls (keyboard + mobile)
  function handleControl(code){
    if(code === 'KeyP'){ togglePause(); return; }
    if(code === 'KeyR'){ reset(); return; }
    if(code === 'KeyQ'){ return; }
    if(!started || paused || gameOver) return;

    if(code === 'ArrowLeft'){
      if(canPlace(piece,-1,0,0)) piece.x -= 1;
    } else if(code === 'ArrowRight'){
      if(canPlace(piece, 1,0,0)) piece.x += 1;
    } else if(code === 'ArrowDown'){
      if(canPlace(piece,0,1,0)) { piece.y += 1; score += 1; updateHUD(); }
      else lock();
    } else if(code === 'ArrowUp'){
      if(canPlace(piece,0,0,1)) piece.r = (piece.r+1) % rotations[piece.kind].length;
    } else if(code === 'Space'){
      hardDrop();
    }
    draw();
  }

  window.addEventListener('keydown', (e) => {
    // é˜²æ­¢æ‰‹æœºå¤–æ¥é”®ç›˜/ç”µè„‘æµè§ˆå™¨æŒ‰ç©ºæ ¼æ»šåŠ¨
    if(e.code === 'Space') e.preventDefault();
    handleControl(e.code);
  });

  // ===== Mobile buttons =====
  const mctl = document.getElementById('mobileControls');
  let repeatTimer = null;
// ===== Auto reserve space for mobile controls (no guessing) =====
function updateBottomSpace(){
  const m = document.getElementById('mobileControls');
  if(!m) return;

  const rect = m.getBoundingClientRect();
  const style = getComputedStyle(m);

  // mctl è‡ªå·±çš„é«˜åº¦ + å®ƒç¦»åº•éƒ¨çš„è·ç¦» + ä¸€ç‚¹ç‚¹å®‰å…¨è¾¹è·
  const bottom = parseFloat(style.bottom || '0') || 0;
  const gap = 12; // ä½ æƒ³æ›´ç´§å°± 8ï¼Œæ›´æ¾å°± 16

  const pad = Math.ceil(rect.height + bottom + gap);
  document.documentElement.style.setProperty('--mctl-pad', pad + 'px');
}

// é¡µé¢åŠ è½½ã€çª—å£å˜åŒ–ã€æ—‹è½¬éƒ½æ›´æ–°
updateBottomSpace();
window.addEventListener('resize', updateBottomSpace);
window.addEventListener('orientationchange', updateBottomSpace);
  function startRepeat(code, ms){
    stopRepeat();
    handleControl(code); // å…ˆè§¦å‘ä¸€æ¬¡
    repeatTimer = setInterval(() => handleControl(code), ms);
  }
  function stopRepeat(){
    if(repeatTimer){ clearInterval(repeatTimer); repeatTimer = null; }
  }

  if(mctl){
    const actToCode = (act) => {
      if(act === 'left') return 'ArrowLeft';
      if(act === 'right') return 'ArrowRight';
      if(act === 'down') return 'ArrowDown';
      if(act === 'rotate') return 'ArrowUp';
      if(act === 'drop') return 'Space';
      if(act === 'pause') return 'KeyP';
      return null;
    };

    // é˜²æ­¢è§¦æ§æ»‘åŠ¨é¡µé¢
    mctl.addEventListener('touchmove', (e) => e.preventDefault(), {passive:false});

    mctl.querySelectorAll('button[data-act]').forEach(btn => {
      const act = btn.dataset.act;
      const code = actToCode(act);

      const onDown = (e) => {
        e.preventDefault();
        if(!code) return;

        // å·¦/å³/ä¸‹ï¼šé•¿æŒ‰è¿å‘
        if(code === 'ArrowLeft' || code === 'ArrowRight') startRepeat(code, 90);
        else if(code === 'ArrowDown') startRepeat(code, 60);
        else handleControl(code); // æ—‹è½¬/ç¡¬é™/æš‚åœï¼šç‚¹ä¸€ä¸‹å³å¯
      };

      const onUp = (e) => {
        e.preventDefault();
        stopRepeat();
      };

      btn.addEventListener('touchstart', onDown, {passive:false});
      btn.addEventListener('touchend', onUp, {passive:false});
      btn.addEventListener('touchcancel', onUp, {passive:false});

      // ç”µè„‘ä¸Šä¹Ÿèƒ½ç‚¹
      btn.addEventListener('mousedown', onDown);
      btn.addEventListener('mouseup', onUp);
      btn.addEventListener('mouseleave', onUp);
      btn.addEventListener('click', (e) => e.preventDefault());
    });
  }
  // block double-tap zoom (iOS)
let lastTouchEnd = 0;
document.addEventListener('touchend', (e) => {
  const now = Date.now();
  if(now - lastTouchEnd <= 300) e.preventDefault();
  lastTouchEnd = now;
}, { passive: false });
  // ===== Mercy Mode (æ”¾åœ¨ IIFE é‡Œé¢) =====
  const btnMercy = document.getElementById('btnMercy');
  const mercyModal = document.getElementById('mercyModal');
  const mercyInput = document.getElementById('mercyInput');
  const mercyTip = document.getElementById('mercyTip');
  const mercyOk = document.getElementById('mercyOk');
  const mercyCancel = document.getElementById('mercyCancel');

  function openMercy(){
    mercyModal.classList.add('show');
    mercyModal.setAttribute('aria-hidden','false');
    mercyInput.value = '';
    mercyTip.textContent = 'è¾“å…¥æ­£ç¡®æš—å·åä¼šç«‹åˆ»å‡é€Ÿã€‚';
    mercyTip.className = 'modal-tip';
    setTimeout(()=> mercyInput.focus(), 50);
  }
  function closeMercy(){
    mercyModal.classList.remove('show');
    mercyModal.setAttribute('aria-hidden','true');
  }

  function setMercy(on){
    mercyOn = on;
    mercyMultiplier = on ? 3.5 : 1;
    btnMercy.textContent = on ? 'æ±‚é¥¶ä¸­ âœ…ï¼ˆç‚¹å–æ¶ˆï¼‰' : 'æ±‚é¥¶æ¨¡å¼ ğŸ¥º';
  }

  function tryEnableMercy(){
    const txt = (mercyInput.value || '').trim();
    if(txt === 'æˆ‘æ˜¯èœé¸¡'){
      setMercy(true);
      mercyTip.textContent = 'å·²å¼€å¯ï¼é€Ÿåº¦å·²å˜æ…¢ âœ…';
      mercyTip.className = 'modal-tip good';
      setTimeout(closeMercy, 450);
    }else{
      mercyTip.textContent = 'ä¸å¯¹å“¦â€¦æç¤ºï¼šæˆ‘æ˜¯èœé¸¡';
      mercyTip.className = 'modal-tip bad';
    }
  }

  btnMercy.addEventListener('click', () => {
    if(mercyOn) setMercy(false);
    else openMercy();
  });

  mercyCancel.addEventListener('click', closeMercy);
  mercyOk.addEventListener('click', tryEnableMercy);
  mercyInput.addEventListener('keydown', (e) => {
    if(e.key === 'Enter') tryEnableMercy();
  });
  mercyModal.addEventListener('click', (e) => {
    if(e.target === mercyModal) closeMercy();
  });
  // ===== Start control =====
let started = false;
const startScreen = document.getElementById('startScreen');
const btnStart = document.getElementById('btnStart');

function startGame(){
  started = true;
  startScreen?.classList.remove('show');
  reset();
}

btnStart?.addEventListener('click', startGame);

// å…è®¸é”®ç›˜ Enter ç›´æ¥å¼€å§‹
window.addEventListener('keydown', (e) => {
  if(!started && (e.code === 'Enter' || e.code === 'Space')){
    e.preventDefault();
    startGame();
  }
});

// è®© tick ä¸€ç›´è·‘ï¼Œä½†æ²¡å¼€å§‹å°±ä¸ä¸‹è½
const _oldTick = tick;
tick = function(t){
  if(!started){
    requestAnimationFrame(tick);
    return;
  }
  _oldTick(t);
};

// åˆå§‹ï¼šä¸è‡ªåŠ¨ resetï¼Œä¸å¼€å§‹ä¸‹è½
startScreen?.classList.add('show');
requestAnimationFrame(tick);
})();
</script>
</body>
</html>
